<h1>Burp Suite Certified Practitioner Certificate</h1>

## Table of Contents
- [Portswigger labs](#Portswigger-labs)
- [API Pentesting](#API-Pentesting)
- [XSS](#cross-site-scripting-xss)
- [SQL Injection](#SQL-injection)

## Portswigger labs

<h3>Lab link: https://portswigger.net/web-security/all-labs</h3>

## <h2>API Pentesting</h2>

<h3>API Enumeration</h3> 

 web fuzzing using **Burp Scanner** (alternative way is web fuzzer such as Feroxbuster or OWASP ZAP)

| API Endpoint Enumeration  | Method |
| ------------- | ------------- |
| Burp Scanner  | automation process  |
| Read API doc  | usually in /api directory  |
| Hidden API endpoint | Burp intruder or Gobuster |


It is also worth checking on JSON, YAML or any JavaScript files as it may contain API endpoints.

| HTTP Method  | Desc. |
| ------------- | ------------- |
| GET  | request resources  |
| POST  | submit requests  |
| Patch | update or modify |



When constructing a request, the JSON format is usually look like this in Burp Suite

```
{
  "username": tester,
  "password": tester
}
```

<h3>Identifying supported HTTP methods</h3>

Basically use **OPTIONS** to see available HTTP options. In HTB, this technique is called **HTTP Tampering** 

<h3>Type Confusion</h3>

The web server sometimes interprets the request differently if the content type isn't what it expect to be.

Usually it involves around **content-type**

```
Example

Content-type: Application/json

This tells the web server, this request contains JSON data
```

<h3>Hidden API endpoint</h3>

Let say you found 
```
POST /api/user/add
```

You can try to fuzzing other endpoint in **/add** using wordlists. You might find other endpoints that look like **/api/user/delete**, **/api/user/update** etc using **Burp Intruder**.

<h3>Mass Assignment Vulnerability</h3>

This attack allows the attackers to insert unknown data parameters in hidden parameters.

```
{
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "isAdmin": "false"
}
```

<h3>Server-side parameter pollution</h3>

This attacks allows the attackers to inject payload in input which later on will be sent to internal system where external users couldnt access. If the input isn't sanitize, it could lead to unauthorized access.It is worth checking every input in API endpoints. We could use query syntax like #, &, = to test.

**Test scenario**
```
GET /userSearch?name=peter&back=/home
```

Use **#** to test. **%23** is the encoded format of #

```
GET /userSearch?name=peter%23foo&back=/home
```

**How website process request through URL path vs API?**

![image](https://github.com/user-attachments/assets/46627c6a-ceb5-450a-93b9-d21ec38353bf)

**Path Traversal in API**

```
GET /edit_profile.php?name=peter%2f..%2fadmin
```

if name parameter isn't sanitize, the web server coould interpret it as **name=peter/../admin**. This /../ is like cd i think.

<h3>Server-side pollution with structured data</h3>

```
POST /myaccount
name=peter","access_level":"administrator
```

We can try to add **access_level** parameter to escalate privielge.

in case it is in JSON 

```
POST /myaccount
{"name": "peter\",\"access_level\":\"administrator"}
```

<h1>We can use Burp Pro feature to automate the process!</h1>


<h1>Resources</h1>

API endpoint wordlists - https://github.com/chrislockard/api_wordlist

Server-Side Prototype Pollution Scanner - https://portswigger.net/blog/server-side-prototype-pollution-scanner

<h1>Recap & keywords</h1>

1. API enumeration = /api, API doc, Burp Scanner

2. API request enumeration = HTTP tampering, OPTIONS

3. Hidden API endpoints = POST /api/user/??? use Burp intruder

4. Server-side Pollution = try query syntax such as & # = in every parameter. For example **name=eheh&name=eheheh**, Server-Side Prototype Pollution Scanner, access_level=administrator etc

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## <h2>Cross-site Scripting (XSS)</h2>

Reflected XSS, where the malicious script comes from the current HTTP request.

Stored XSS, where the malicious script comes from the website's database.

DOM-based XSS, where the vulnerability exists in client-side code rather than server-side code.

<h2>Automated tool with Burp Pro Vulnerability Scanner feature</h2>

Details: https://portswigger.net/burp/vulnerability-scanner

<h2>Content security policy</h2>

Content security policy or CSP is used to detect XSS.

DOM-based XSS 

Let say 

```
<img src="/resources/images/tracker.gif?searchTerms=">
```

We can try to create img script tag by 

```
"><svg onload=alert(1)> 
```

So, it will look like this

```
<img src="/resources/images/tracker.gif?searchTerms="><svg onload=alert(1)>
```
Basically just another tag in HTML


<h1>Resources</h1>

XSS cheatsheet - https://portswigger.net/web-security/cross-site-scripting/cheat-sheet

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## <h2>SQL Injection</h2>

Can be found especially in queries

Useful command when we want to know more about table information.

```
SELECT * FROM information_schema.tables
```

<h3>How to test SQL injection</h3>

Use ' = if there is SQL error message, this means the web app is vulnerable to SQL injection

Ex.

```
https://insecure-website.com/products?category=Gifts'--
```

This means that the statement after -- will be recognized as a comment. In this case the only part that SQL statement will be execute is ?category=Gift

```
SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
```

**Boolean conditions** checks for conditions

try

```
OR 1=1 # this always returns true
```

or

```
OR 1=2 
```

<h1>THE EASIEST WAY TO DETECT SQL INJECTION IS TO USE BURP SCANNER!</h1>

**Union Injection**

**How to check for database information?**

| Database  | Command |
| ------------- | ------------- |
| Microsoft, MySQL  | SELECT @@version |
| Oracle |SELECT * FROM v$version |
| PostgreSQL | SELECT version() |


Basically retrieve the another table by using UNION. It allows attackers to use SELECT command twice.

```
' UNION SELECT username, password FROM users--
```

Normally, when we test union injection. Firstly, check how many columns the table have. Secondly check which column has a suitable datatype. so that we can use SQL statement to retreive the respective data we want to expose.

```
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
```

another way

```
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--
```

**In Oracle database**

We have to add **DUAL** after SELECT / FROM because it is a bult-in. Can't run without it.

```
' UNION SELECT NULL FROM DUAL--
```

<h2>WAF Bypass</h2>

We can encode or we can obfuscate the sql statement to bypass the WAF.

Ex. The below is XML-based SQL injection

```
<stockCheck>
    <productId>123</productId>
    <storeId>999 &#x53;ELECT * FROM information_schema.tables</storeId>
</stockCheck>
```

If we want to bypass specific technology, Burp suite provides many extension to help us bypass WAF. For example, if we want to bypass WAF that is implemented in XML, we can use Hackvertor extension to encode our SQL injection command to potentially bypass WAF.



**Out-of-band application security testing (OAST)**

This attacks uses external service to retreive SQL injection attack results. In Burp Suite, it has a dedicated testing server which allows users to perform OOB. This is useful when perform blind sql injection


**Blind SQL Injection**

the SQL injection might work but it doesn't show an error. We can use time delay to identify that or add additional logic condition to trigger an error.



<h1>Resources</h1>

SQL injection cheatsheet - https://portswigger.net/web-security/sql-injection/cheat-sheet
