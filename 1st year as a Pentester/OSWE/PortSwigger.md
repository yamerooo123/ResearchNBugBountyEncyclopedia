<h1>PortSwigger academy</h1>

## Table of Contents
- [Portswigger labs](#Portswigger-labs)
- [API Pentesting](#API-Pentesting)
- [XSS](#cross-site-scripting-xss)
- [SQL Injection](#SQL-injection)
  - [NoSQL Injection](#NoSQL-injection)
- [CORS](#CORS)

## Portswigger labs

<h3>Lab link: https://portswigger.net/web-security/all-labs</h3>

## <h2>API Pentesting</h2>

<h3>API Enumeration</h3> 

 web fuzzing using **Burp Scanner** (alternative way is web fuzzer such as Feroxbuster or OWASP ZAP)

| API Endpoint Enumeration  | Method |
| ------------- | ------------- |
| Burp Scanner  | automation process  |
| Read API doc  | usually in /api directory  |
| Hidden API endpoint | Burp intruder or Gobuster |


It is also worth checking on JSON, YAML or any JavaScript files as it may contain API endpoints.

| HTTP Method  | Desc. |
| ------------- | ------------- |
| GET  | request resources  |
| POST  | submit requests  |
| Patch | update or modify |



When constructing a request, the JSON format is usually look like this in Burp Suite

```
{
  "username": tester,
  "password": tester
}
```

<h3>Identifying supported HTTP methods</h3>

Basically use **OPTIONS** to see available HTTP options. In HTB, this technique is called **HTTP Tampering** 

<h3>Type Confusion</h3>

The web server sometimes interprets the request differently if the content type isn't what it expect to be.

Usually it involves around **content-type**

```
Example

Content-type: Application/json

This tells the web server, this request contains JSON data
```

<h3>Hidden API endpoint</h3>

Let say you found 
```
POST /api/user/add
```

You can try to fuzzing other endpoint in **/add** using wordlists. You might find other endpoints that look like **/api/user/delete**, **/api/user/update** etc using **Burp Intruder**.

<h3>Mass Assignment Vulnerability</h3>

This attack allows the attackers to insert unknown data parameters in hidden parameters.

```
{
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "isAdmin": "false"
}
```

<h3>Server-side parameter pollution</h3>

This attacks allows the attackers to inject payload in input which later on will be sent to internal system where external users couldnt access. If the input isn't sanitize, it could lead to unauthorized access.It is worth checking every input in API endpoints. We could use query syntax like #, &, = to test.

**Test scenario**
```
GET /userSearch?name=peter&back=/home
```

Use **#** to test. **%23** is the encoded format of #

```
GET /userSearch?name=peter%23foo&back=/home
```

**How website process request through URL path vs API?**

![image](https://github.com/user-attachments/assets/46627c6a-ceb5-450a-93b9-d21ec38353bf)

**Path Traversal in API**

```
GET /edit_profile.php?name=peter%2f..%2fadmin
```

if name parameter isn't sanitize, the web server coould interpret it as **name=peter/../admin**. This /../ is like cd i think.

<h3>Server-side pollution with structured data</h3>

```
POST /myaccount
name=peter","access_level":"administrator
```

We can try to add **access_level** parameter to escalate privielge.

in case it is in JSON 

```
POST /myaccount
{"name": "peter\",\"access_level\":\"administrator"}
```

<h1>We can use Burp Pro feature to automate the process!</h1>


<h1>Resources</h1>

API endpoint wordlists - https://github.com/chrislockard/api_wordlist

Server-Side Prototype Pollution Scanner - https://portswigger.net/blog/server-side-prototype-pollution-scanner

<h1>Recap & keywords</h1>

1. API enumeration = /api, API doc, Burp Scanner

2. API request enumeration = HTTP tampering, OPTIONS

3. Hidden API endpoints = POST /api/user/??? use Burp intruder

4. Server-side Pollution = try query syntax such as & # = in every parameter. For example **name=eheh&name=eheheh**, Server-Side Prototype Pollution Scanner, access_level=administrator etc

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## <h2>Cross-site Scripting (XSS)</h2>

Reflected XSS, where the malicious script comes from the current HTTP request.

Stored XSS, where the malicious script comes from the website's database.

DOM-based XSS, where the vulnerability exists in client-side code rather than server-side code.

<h2>Automated tool with Burp Pro Vulnerability Scanner feature</h2>

Details: https://portswigger.net/burp/vulnerability-scanner

<h2>Content security policy</h2>

Content security policy or CSP is used to detect XSS.

DOM-based XSS 

Let say 

```
<img src="/resources/images/tracker.gif?searchTerms=">
```

We can try to create img script tag by 

```
"><svg onload=alert(1)> 
```

So, it will look like this

```
<img src="/resources/images/tracker.gif?searchTerms="><svg onload=alert(1)>
```
Basically just another tag in HTML


<h1>Resources</h1>

XSS cheatsheet - https://portswigger.net/web-security/cross-site-scripting/cheat-sheet

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## <h2>SQL Injection</h2>

Can be found especially in queries

Useful command when we want to know more about table information.

```
SELECT * FROM information_schema.tables
```

If you want to see tables you can try to exploit it with union-based sql injection.

```
'+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables--
```

In case we want to retreive tables more than one, we can use concatenation to achieve that.

```
'+UNION+SELECT+NULL,username||'~'||password+FROM+users--
```

<h3>How to test SQL injection</h3>

Use ' = if there is SQL error message, this means the web app is vulnerable to SQL injection

Ex.

```
https://insecure-website.com/products?category=Gifts'--
```

This means that the statement after -- will be recognized as a comment. In this case the only part that SQL statement will be execute is ?category=Gift

```
SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
```

**Boolean conditions** checks for conditions

try

```
OR 1=1 # this always returns true
```

or

```
OR 1=2 
```

<h1>THE EASIEST WAY TO DETECT SQL INJECTION IS TO USE BURP SCANNER!</h1>

**Union Injection**

**How to check for database information?**

| Database  | Command |
| ------------- | ------------- |
| Microsoft, MySQL  | SELECT @@version |
| Oracle |SELECT * FROM v$version |
| PostgreSQL | SELECT version() |


Basically retrieve the another table by using UNION. It allows attackers to use SELECT command twice.

```
' UNION SELECT username, password FROM users--
```

Normally, when we test union injection. Firstly, check how many columns the table have. Secondly check which column has a suitable datatype. so that we can use SQL statement to retreive the respective data we want to expose.

```
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
```

another way

```
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--
```

**In Oracle database**

We have to add **DUAL** after SELECT / FROM because it is a bult-in. Can't run without it.

```
' UNION SELECT NULL FROM DUAL--
```

**Oracle SQL injection exaple**

```
Accessories'+UNION+SELECT+banner,NULL+FROM+v$version--
```

<h2>WAF Bypass</h2>

We can encode or we can obfuscate the sql statement to bypass the WAF.

Ex. The below is XML-based SQL injection

```
<stockCheck>
    <productId>123</productId>
    <storeId>999 &#x53;ELECT * FROM information_schema.tables</storeId>
</stockCheck>
```

If we want to bypass specific technology, Burp suite provides many extension to help us bypass WAF. For example, if we want to bypass WAF that is implemented in XML, we can use Hackvertor extension to encode our SQL injection command to potentially bypass WAF.



**Out-of-band application security testing (OAST)**

This attacks uses external service to retreive SQL injection attack results. In Burp Suite, it has a dedicated testing server which allows users to perform OOB. This is useful when perform blind sql injection

the SQL injection might work but it doesn't show an error. We can use time delay to identify that or add additional logic condition to trigger an error.

```
Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4
```

The above cookie is a tracking cookie. This cookie is vulnerable to SQL injection since the value of TrackingID is basically SQL statement. However, we couldnt simply use union to exploit this instead we use blind sql injection.

Example

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 'm
```

The above sql statement checks for administrator in Users table with the logic 1 = 1 is always true. if it is valid then it is greater than m. This means that as long as the welcome back notification is triggered. the result is positive. Now we know the first character of this user's password we can try

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 't
```

This time the welcome back notification didn't show up. This means that the letter t isn't the 2nd character of the user's password. Now we try "s".

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 's
```

This time it returns a welcome back message, indicating valid statement.

In conclusion, so far we that this user's password is start with "m" and the second letter is "s". we repeat the process until we found a valid password.


## <h2>NoSQL Injection</h2>

A famouse database. It is different from traditional databases because it uses different query languages. 

Because of the variety of query that's why we can abuse many query syntax as there are many diffrent methods we can try.

**How do we test NoSQL injection?**

the concept is as the same as how we try to exploit sql injection

try:

```
'"`{
;$Foo}
$Foo \xYZ
```

in JSON query try:

```
'\"`{\r;$Foo}\n$Foo \\xYZ\u0000
```

**NoSQL statement check**

False statement

```
Gifts' && 0 && 'x
```

True statement

```
Gifts' && 1 && 'x
```

Always true

```
Gifts'||1||'
```

We can also try to add null value. This works like a comment.

```
'%00
```

The result of null value is whatever statement after null value won't be processed. That's how MongoDB intreprets

**NoSQL injection with Operator Injection**


| Operator  | Meaning |
| ------------- | ------------- |
| $where  | Matches documents that satisfy a JavaScript expression. |
| $ne  |Matches all values that are not equal to a specified value. |
| $in | Matches all of the values specified in an array. |
| $regex | Selects documents where values match a specified regular expression. |

To exploit NoSQL Operator Injection, we can try nested objects.

In JSON

**{"username":"wiener"} becomes {"username":{"$ne":"invalid"}}**

In URL path

**username[$ne]=invalid**

<h3>Things to do if URL path doesn't work:</h3>

1. HTTP tampering. Change GET to POST
2. Change the content-type to Application/json
3. Do it in JSON query

<h3>I won't go deeper like how to manual exploit this. The reason is i just want to know how it work and how can i detect it. If i want to exploitm i will use automating tool </h3>

<h1>Resources</h1>

SQL injection cheatsheet - https://portswigger.net/web-security/sql-injection/cheat-sheet

NoSQL automating tool - https://github.com/codingo/NoSQLMap


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## <h2>CORS</h2>

CORS or cross origin resource sharing is a browser mechanism, allowing the web app to use resource across domains. However, if this browser mechanism isn't well implemented, it could become an attacker vector.


